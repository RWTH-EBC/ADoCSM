#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model AixLib.Fluid.Actuators.Valves.Examples.TwoWayValvePressureIndependent
 Dymola Version 2019 (64-bit), 2018-04-11 translated this at Fri Dec 28 20:18:06 2018

   */

#include <matrixop.h>
static const char* DymArrays2[1]={"SimpleLiquidWater"};
#if defined(DynSimStruct) || defined(BUILDFMU)
static double DymArrays1[3]={0.0, 0.0, 0.0};
static double DymArrays0[5]={0.0, 0.0, 0.0, 0.0, 0.0};
#endif
/* Declaration of C-structs */
/* Prototypes for functions used in model */
DYMOLA_STATIC double   AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp
  (double  dp0_0, double  k0_0, double  mx_0flowx_0turbulent);
DYMOLA_STATIC double   AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dpx_0der
  (double  dp0_0, double  k0_0, double  mx_0flowx_0turbulent, double  dpx_0der);
DYMOLA_STATIC double   AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dpx_0der2
  (double  dp0_0, double  k0_0, double  mx_0flowx_0turbulent, double  dpx_0der, 
  double  dpx_0der2);
DYMOLA_STATIC double   AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent);
DYMOLA_STATIC double   AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent, double  
  mx_0flowx_0der);
DYMOLA_STATIC double   AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der2
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent, double  
  mx_0flowx_0der, double  mx_0flowx_0der2);
DYMOLA_STATIC double   AixLib_Utilities_Math_Functions_quinticHermite(double  
  x0_0, double  x10_0, double  x20_0, double  y10_0, double  y20_0, double  
  y1d0_0, double  y2d0_0, double  y1dd0_0, double  y2dd0_0);
DYMOLA_STATIC double   AixLib_Utilities_Math_Functions_quinticHermite__derf(
  double  x0_0, double  x10_0, double  x20_0, double  y10_0, double  y20_0, 
  double  y1d0_0, double  y2d0_0, double  y1dd0_0, double  y2dd0_0, double  
  xx_0der23, double  x1x_0der23, double  x2x_0der23, double  y1x_0der23, double 
   y2x_0der23, double  y1dx_0der23, double  y2dx_0der23, double  y1ddx_0der23, 
  double  y2ddx_0der23);
DYMOLA_STATIC void Modelica_Fluid_Utilities_checkBoundary(const char*  
  mediumName0_0, StringArray   substanceNames0_0, int  singleState0_0, int  
  definex_0p, RealArray   Xx_0boundary, const char*  modelName0_0);
/* Codes used in model */

/* Flattened Modelica model:

function AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp
discrete input Real dp(unit = "Pa", displayUnit = "Pa") "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
discrete input Real k(min = 0.0) "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
discrete input Real m_flow_turbulent(unit = "kg/s", min = 0.0) "Mass flow rate where transition to turbulent flow occurs";
discrete output Real m_flow(unit = "kg/s") "Mass flow rate in design flow direction";
protected 
discrete Real dp_turbulent(start = (m_flow_turbulent/k)^2, unit = "Pa", displayUnit = "bar") "Pressure where flow changes to turbulent";
discrete Real dpNorm(start = dp/dp_turbulent) "Normalised pressure difference";
discrete Real dpNormSq(start = dpNorm^2) "Square of normalised pressure difference";
public 
algorithm 
m_flow := (if noEvent(abs(dp) > dp_turbulent) then noEvent((if dp > 0 then 1 else (if dp < 0 then -1 else 0)))*k*sqrt(abs(dp)) else (1.40625+(0.15625*dpNormSq-0.5625)*dpNormSq)*m_flow_turbulent*dpNorm);
annotation(derivative(zeroDerivative=k, zeroDerivative=m_flow_turbulent)=AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der, LateInline=true, smoothOrder=2);
end AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp;

  */
DYMOLA_STATIC double   AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp
  (double  dp0_0, double  k0_0, double  mx_0flowx_0turbulent) {
  PushContext("AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp")
  {
    /* Declare outputs and temporaries */
    double   mx_0flow;
    double   dpx_0turbulent;
    double   dpNorm0_0;
    double   dpNormSq0_0;
    mx_0flow=0;
    dpx_0turbulent = sqr(divmacro(mx_0flowx_0turbulent,"m_flow_turbulent",k0_0,
      "k"));
    dpNorm0_0 = divmacro(dp0_0,"dp",dpx_0turbulent,"dp_turbulent");
    dpNormSq0_0 = sqr(dpNorm0_0);
    /* Start of real code */
      mx_0flow = IF fabs(dp0_0) > dpx_0turbulent THEN (IF dp0_0 > 0 THEN 1 ELSE 
        IF dp0_0 < 0 THEN -1 ELSE 0)*k0_0*sqrtGuarded(fabs(dp0_0),"abs(dp)")
         ELSE (1.40625+(0.15625*dpNormSq0_0-0.5625)*dpNormSq0_0)*
        mx_0flowx_0turbulent*dpNorm0_0;
    /* Output section */
    PopContext()
    return mx_0flow;
  }}

/* Flattened Modelica model:

function AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der
discrete input Real dp(unit = "Pa", displayUnit = "Pa") "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
discrete input Real k(min = 0.0) "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
discrete input Real m_flow_turbulent(unit = "kg/s", min = 0.0) "Mass flow rate where transition to turbulent flow occurs";
discrete input Real dp_der "Derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
discrete output Real m_flow_der(unit = "kg/s2") "Derivative of mass flow rate in design flow direction";
protected 
discrete Real dp_turbulent(start = (m_flow_turbulent/k)^2, unit = "Pa", displayUnit = "bar") "Pressure where flow changes to turbulent";
discrete Real dpNormSq(start = (dp/dp_turbulent)^2) "Square of normalised pressure difference";
public 
algorithm 
m_flow_der := (if noEvent(abs(dp) > dp_turbulent) then 0.5*k/sqrt(abs(dp)) else (1.40625+(0.78125*dpNormSq-1.6875)*dpNormSq)*m_flow_turbulent/dp_turbulent)*dp_der;
annotation(derivative(order=2, zeroDerivative=k, zeroDerivative=m_flow_turbulent)=AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der2, LateInline=true, smoothOrder=1);
end AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der;

  */
DYMOLA_STATIC double   AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dpx_0der
  (double  dp0_0, double  k0_0, double  mx_0flowx_0turbulent, double  dpx_0der)
   {
  PushContext("AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der")
  {
    /* Declare outputs and temporaries */
    double   mx_0flowx_0der;
    double   dpx_0turbulent;
    double   dpNormSq0_0;
    mx_0flowx_0der=0;
    dpx_0turbulent = sqr(divmacro(mx_0flowx_0turbulent,"m_flow_turbulent",k0_0,
      "k"));
    dpNormSq0_0 = sqr(divmacro(dp0_0,"dp",dpx_0turbulent,"dp_turbulent"));
    /* Start of real code */
      mx_0flowx_0der = (IF fabs(dp0_0) > dpx_0turbulent THEN divmacro(0.5*k0_0,
        "0.5*k",sqrtGuarded(fabs(dp0_0),"abs(dp)"),"sqrt(abs(dp))") ELSE 
        divmacro((1.40625+(0.78125*dpNormSq0_0-1.6875)*dpNormSq0_0)*
        mx_0flowx_0turbulent,"(1.40625+(0.78125*dpNormSq-1.6875)*dpNormSq)*m_flow_turbulent",
        dpx_0turbulent,"dp_turbulent"))*dpx_0der;
    /* Output section */
    PopContext()
    return mx_0flowx_0der;
  }}

/* Flattened Modelica model:

function AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der2
discrete input Real dp(unit = "Pa", displayUnit = "Pa") "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
discrete input Real k(min = 0.0) "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
discrete input Real m_flow_turbulent(unit = "kg/s", min = 0.0) "Mass flow rate where transition to turbulent flow occurs";
discrete input Real dp_der "1st derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
discrete input Real dp_der2 "2nd derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
discrete output Real m_flow_der2 "2nd derivative of mass flow rate in design flow direction";
protected 
discrete Real dp_turbulent(start = (m_flow_turbulent/k)^2, unit = "Pa", displayUnit = "bar") "Pressure where flow changes to turbulent";
discrete Real dpNorm(start = dp/dp_turbulent) "Normalised pressure difference";
discrete Real dpNormSq(start = dpNorm^2) "Square of normalised pressure difference";
public 
algorithm 
m_flow_der2 := (if noEvent(abs(dp) > dp_turbulent) then 0.5*k/sqrt(abs(dp))*(( -0.5/dp*dp_der^2)+dp_der2) else m_flow_turbulent/dp_turbulent*((1.40625+(0.78125*dpNormSq-1.6875)*dpNormSq)*dp_der2+((-3.375)+3.125*dpNormSq)*dpNorm/dp_turbulent*dp_der^2));
annotation(Inline=true, smoothOrder=0);
end AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der2;

  */
DYMOLA_STATIC double   AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dpx_0der2
  (double  dp0_0, double  k0_0, double  mx_0flowx_0turbulent, double  dpx_0der, 
  double  dpx_0der2) {
  PushContext("AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der2")
  {
    /* Declare outputs and temporaries */
    double   mx_0flowx_0der2;
    double   dpx_0turbulent;
    double   dpNorm0_0;
    double   dpNormSq0_0;
    mx_0flowx_0der2=0;
    dpx_0turbulent = sqr(divmacro(mx_0flowx_0turbulent,"m_flow_turbulent",k0_0,
      "k"));
    dpNorm0_0 = divmacro(dp0_0,"dp",dpx_0turbulent,"dp_turbulent");
    dpNormSq0_0 = sqr(dpNorm0_0);
    /* Start of real code */
      mx_0flowx_0der2 = IF fabs(dp0_0) > dpx_0turbulent THEN divmacro(0.5*k0_0,
        "0.5*k",sqrtGuarded(fabs(dp0_0),"abs(dp)"),"sqrt(abs(dp))")*(( -divmacro
        (0.5,"0.5",dp0_0,"dp")*sqr(dpx_0der))+dpx_0der2) ELSE divmacro(
        mx_0flowx_0turbulent,"m_flow_turbulent",dpx_0turbulent,"dp_turbulent")*(
        (1.40625+(0.78125*dpNormSq0_0-1.6875)*dpNormSq0_0)*dpx_0der2+divmacro(((
        -3.375)+3.125*dpNormSq0_0)*dpNorm0_0,"((-3.375)+3.125*dpNormSq)*dpNorm",
        dpx_0turbulent,"dp_turbulent")*sqr(dpx_0der));
    /* Output section */
    PopContext()
    return mx_0flowx_0der2;
  }}

/* Flattened Modelica model:

function AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow
discrete input Real m_flow(unit = "kg/s") "Mass flow rate in design flow direction";
discrete input Real k "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
discrete input Real m_flow_turbulent(unit = "kg/s", min = 0.0) "Mass flow rate where transition to turbulent flow occurs";
discrete output Real dp(unit = "Pa", displayUnit = "Pa") "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
protected 
discrete Real dp_turbulent(start = (m_flow_turbulent/k)^2, unit = "Pa", displayUnit = "bar") "Pressure where flow changes to turbulent";
discrete Real m_flowNorm(start = m_flow/m_flow_turbulent) "Normalised mass flow rate";
discrete Real m_flowNormSq(start = m_flowNorm^2) "Square of normalised mass flow rate";
public 
algorithm 
dp := (if noEvent(abs(m_flow) > m_flow_turbulent) then noEvent((if m_flow > 0 then 1 else (if m_flow < 0 then -1 else 0)))*(m_flow/k)^2 else (0.375+(0.75-0.125*m_flowNormSq)*m_flowNormSq)*dp_turbulent*m_flowNorm);
annotation(derivative(zeroDerivative=k, zeroDerivative=m_flow_turbulent)=AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der, LateInline=true, smoothOrder=2);
end AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow;

  */
DYMOLA_STATIC double   AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent) {
  PushContext("AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow")
  {
    /* Declare outputs and temporaries */
    double   dp0_0;
    double   dpx_0turbulent;
    double   mx_0flowNorm;
    double   mx_0flowNormSq;
    dp0_0=0;
    dpx_0turbulent = sqr(divmacro(mx_0flowx_0turbulent,"m_flow_turbulent",k0_0,
      "k"));
    mx_0flowNorm = divmacro(mx_0flow,"m_flow",mx_0flowx_0turbulent,
      "m_flow_turbulent");
    mx_0flowNormSq = sqr(mx_0flowNorm);
    /* Start of real code */
      dp0_0 = IF fabs(mx_0flow) > mx_0flowx_0turbulent THEN (IF mx_0flow > 0
         THEN 1 ELSE IF mx_0flow < 0 THEN -1 ELSE 0)*sqr(divmacro(mx_0flow,
        "m_flow",k0_0,"k")) ELSE (0.375+(0.75-0.125*mx_0flowNormSq)*
        mx_0flowNormSq)*dpx_0turbulent*mx_0flowNorm;
    /* Output section */
    PopContext()
    return dp0_0;
  }}

/* Flattened Modelica model:

function AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der
discrete input Real m_flow(unit = "kg/s") "Mass flow rate in design flow direction";
discrete input Real k "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
discrete input Real m_flow_turbulent(unit = "kg/s", min = 0.0) "Mass flow rate where transition to turbulent flow occurs";
discrete input Real m_flow_der(unit = "kg/s2") "Derivative of mass flow rate in design flow direction";
discrete output Real dp_der "Derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
protected 
discrete Real dp_turbulent(start = (m_flow_turbulent/k)^2, unit = "Pa", displayUnit = "bar") "Pressure where flow changes to turbulent";
discrete Real m_flowNormSq(start = (m_flow/m_flow_turbulent)^2) "Square of normalised mass flow rate";
public 
algorithm 
dp_der := (if noEvent(abs(m_flow) > m_flow_turbulent) then noEvent((if m_flow > 0 then 1 else (if m_flow < 0 then -1 else 0)))*2*m_flow/k^2 else (0.375+(2.25-0.625*m_flowNormSq)*m_flowNormSq)*dp_turbulent/m_flow_turbulent)*m_flow_der;
annotation(derivative(order=2, zeroDerivative=k, zeroDerivative=m_flow_turbulent)=AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der2, LateInline=true, smoothOrder=1);
end AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der;

  */
DYMOLA_STATIC double   AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent, double  
  mx_0flowx_0der) {
  PushContext("AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der")
  {
    /* Declare outputs and temporaries */
    double   dpx_0der;
    double   dpx_0turbulent;
    double   mx_0flowNormSq;
    dpx_0der=0;
    dpx_0turbulent = sqr(divmacro(mx_0flowx_0turbulent,"m_flow_turbulent",k0_0,
      "k"));
    mx_0flowNormSq = sqr(divmacro(mx_0flow,"m_flow",mx_0flowx_0turbulent,
      "m_flow_turbulent"));
    /* Start of real code */
      dpx_0der = (IF fabs(mx_0flow) > mx_0flowx_0turbulent THEN divmacro((IF 
        mx_0flow > 0 THEN 1 ELSE IF mx_0flow < 0 THEN -1 ELSE 0)*2*mx_0flow,
        "noEvent((if m_flow > 0 then 1 else (if m_flow < 0 then -1 else 0)))*2*m_flow",
        sqr(k0_0),"k^2") ELSE divmacro((0.375+(2.25-0.625*mx_0flowNormSq)*
        mx_0flowNormSq)*dpx_0turbulent,"(0.375+(2.25-0.625*m_flowNormSq)*m_flowNormSq)*dp_turbulent",
        mx_0flowx_0turbulent,"m_flow_turbulent"))*mx_0flowx_0der;
    /* Output section */
    PopContext()
    return dpx_0der;
  }}

/* Flattened Modelica model:

function AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der2
discrete input Real m_flow(unit = "kg/s") "Mass flow rate in design flow direction";
discrete input Real k "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
discrete input Real m_flow_turbulent(unit = "kg/s", min = 0.0) "Mass flow rate where transition to turbulent flow occurs";
discrete input Real m_flow_der(unit = "kg/s2") "1st derivative of mass flow rate in design flow direction";
discrete input Real m_flow_der2(unit = "kg/s3") "2nd derivative of mass flow rate in design flow direction";
discrete output Real dp_der2 "2nd derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
protected 
discrete Real dp_turbulent(start = (m_flow_turbulent/k)^2, unit = "Pa", displayUnit = "bar") "Pressure where flow changes to turbulent";
discrete Real m_flowNorm(start = m_flow/m_flow_turbulent) "Normalised mass flow rate";
discrete Real m_flowNormSq(start = m_flowNorm^2) "Square of normalised mass flow rate";
public 
algorithm 
dp_der2 := (if noEvent(abs(m_flow) > m_flow_turbulent) then noEvent((if m_flow > 0 then 1 else (if m_flow < 0 then -1 else 0)))*2/k^2*(m_flow_der^2+m_flow*m_flow_der2) else dp_turbulent/m_flow_turbulent*((0.375+(2.25-0.625*m_flowNormSq)*m_flowNormSq)*m_flow_der2+(4.5-2.5*m_flowNormSq)*m_flowNorm/m_flow_turbulent*m_flow_der^2));
annotation(Inline=true, smoothOrder=0);
end AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der2;

  */
DYMOLA_STATIC double   AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der2
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent, double  
  mx_0flowx_0der, double  mx_0flowx_0der2) {
  PushContext("AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der2")
  {
    /* Declare outputs and temporaries */
    double   dpx_0der2;
    double   dpx_0turbulent;
    double   mx_0flowNorm;
    double   mx_0flowNormSq;
    dpx_0der2=0;
    dpx_0turbulent = sqr(divmacro(mx_0flowx_0turbulent,"m_flow_turbulent",k0_0,
      "k"));
    mx_0flowNorm = divmacro(mx_0flow,"m_flow",mx_0flowx_0turbulent,
      "m_flow_turbulent");
    mx_0flowNormSq = sqr(mx_0flowNorm);
    /* Start of real code */
      dpx_0der2 = IF fabs(mx_0flow) > mx_0flowx_0turbulent THEN divmacro((IF 
        mx_0flow > 0 THEN 1 ELSE IF mx_0flow < 0 THEN -1 ELSE 0)*2,
        "noEvent((if m_flow > 0 then 1 else (if m_flow < 0 then -1 else 0)))*2",
        sqr(k0_0),"k^2")*(sqr(mx_0flowx_0der)+mx_0flow*mx_0flowx_0der2) ELSE 
        divmacro(dpx_0turbulent,"dp_turbulent",mx_0flowx_0turbulent,
        "m_flow_turbulent")*((0.375+(2.25-0.625*mx_0flowNormSq)*mx_0flowNormSq)*
        mx_0flowx_0der2+divmacro((4.5-2.5*mx_0flowNormSq)*mx_0flowNorm,
        "(4.5-2.5*m_flowNormSq)*m_flowNorm",mx_0flowx_0turbulent,
        "m_flow_turbulent")*sqr(mx_0flowx_0der));
    /* Output section */
    PopContext()
    return dpx_0der2;
  }}

/* Flattened Modelica model:

function AixLib.Utilities.Math.Functions.quinticHermite
discrete input Real x "Abscissa value";
discrete input Real x1 "Lower abscissa value";
discrete input Real x2 "Upper abscissa value";
discrete input Real y1 "Lower ordinate value";
discrete input Real y2 "Upper ordinate value";
discrete input Real y1d "Lower derivative";
discrete input Real y2d "Upper derivative";
discrete input Real y1dd "Lower second derivative";
discrete input Real y2dd "Upper second derivative";
discrete output Real y "Interpolated ordinate value";
protected 
discrete Real h(start = x2-x1);
discrete Real hpow2(start = h*h);
discrete Real t(start = (x-x1)/h);
discrete Real tpow2(start = t*t);
discrete Real tpow3(start = tpow2*t);
discrete Real tpow4(start = tpow3*t);
discrete Real tpow5(start = tpow4*t);
discrete Real H0(start = 1.0+15*tpow4-10*tpow3-6*tpow5);
discrete Real H1(start = t-6*tpow3+8*tpow4-3*tpow5);
discrete Real H2(start = 0.5*(tpow2-3*tpow3+3*tpow4-tpow5));
discrete Real H3(start = 0.5*tpow3-tpow4+0.5*tpow5);
discrete Real H4(start = 7*tpow4-4*tpow3-3*tpow5);
discrete Real H5(start = 1-H0);
public 
algorithm 
y := H0*y1+H1*y1d*h+H2*y1dd*hpow2+H3*y2dd*hpow2+H4*y2d*h+H5*y2;
annotation(derivative=AixLib.Utilities.Math.Functions.quinticHermite:derf, smoothOrder=99);
end AixLib.Utilities.Math.Functions.quinticHermite;

  */
DYMOLA_STATIC double   AixLib_Utilities_Math_Functions_quinticHermite(double  
  x0_0, double  x10_0, double  x20_0, double  y10_0, double  y20_0, double  
  y1d0_0, double  y2d0_0, double  y1dd0_0, double  y2dd0_0) {
  PushContext("AixLib.Utilities.Math.Functions.quinticHermite")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   h0_0;
    double   hpow20_0;
    double   t0_0;
    double   tpow20_0;
    double   tpow30_0;
    double   tpow40_0;
    double   tpow50_0;
    double   H00_0;
    double   H10_0;
    double   H20_0;
    double   H30_0;
    double   H40_0;
    double   H50_0;
    y0_0=0;
    h0_0 = x20_0-x10_0;
    hpow20_0 = h0_0*h0_0;
    t0_0 = divmacro(x0_0-x10_0,"x-x1",h0_0,"h");
    tpow20_0 = t0_0*t0_0;
    tpow30_0 = tpow20_0*t0_0;
    tpow40_0 = tpow30_0*t0_0;
    tpow50_0 = tpow40_0*t0_0;
    H00_0 = 1.0+15*tpow40_0-10*tpow30_0-6*tpow50_0;
    H10_0 = t0_0-6*tpow30_0+8*tpow40_0-3*tpow50_0;
    H20_0 = 0.5*(tpow20_0-3*tpow30_0+3*tpow40_0-tpow50_0);
    H30_0 = 0.5*tpow30_0-tpow40_0+0.5*tpow50_0;
    H40_0 = 7*tpow40_0-4*tpow30_0-3*tpow50_0;
    H50_0 = 1-H00_0;
    /* Start of real code */
      y0_0 = H00_0*y10_0+H10_0*y1d0_0*h0_0+H20_0*y1dd0_0*hpow20_0+H30_0*y2dd0_0*
        hpow20_0+H40_0*y2d0_0*h0_0+H50_0*y20_0;
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function AixLib.Utilities.Math.Functions.quinticHermite:derf
discrete input Real x;
discrete input Real x1;
discrete input Real x2;
discrete input Real y1;
discrete input Real y2;
discrete input Real y1d;
discrete input Real y2d;
discrete input Real y1dd;
discrete input Real y2dd;
protected 
discrete Real y;
discrete Real h(start = x2-x1);
discrete Real hpow2(start = h*h);
discrete Real t(start = (x-x1)/h);
discrete Real tpow2(start = t*t);
discrete Real tpow3(start = tpow2*t);
discrete Real tpow4(start = tpow3*t);
discrete Real tpow5(start = tpow4*t);
discrete Real H0(start = 1.0+15*tpow4-10*tpow3-6*tpow5);
discrete Real H1(start = t-6*tpow3+8*tpow4-3*tpow5);
discrete Real H2(start = 0.5*(tpow2-3*tpow3+3*tpow4-tpow5));
discrete Real H3(start = 0.5*tpow3-tpow4+0.5*tpow5);
discrete Real H4(start = 7*tpow4-4*tpow3-3*tpow5);
discrete Real H5(start = 1-H0);
public 
discrete input Real x_der23;
discrete input Real x1_der23;
discrete input Real x2_der23;
discrete input Real y1_der23;
discrete input Real y2_der23;
discrete input Real y1d_der23;
discrete input Real y2d_der23;
discrete input Real y1dd_der23;
discrete input Real y2dd_der23;
discrete output Real y_der23;
protected 
discrete Real h_der23(start = x2_der23-x1_der23);
discrete Real hpow2_der23(start = 2.0*(h_der23*h));
discrete Real t_der23(start = (x_der23-x1_der23)/h-(x-x1)*h_der23/h^2);
discrete Real tpow2_der23(start = 2.0*(t_der23*t));
discrete Real tpow3_der23(start = tpow2_der23*t+tpow2*t_der23);
discrete Real tpow4_der23(start = tpow3_der23*t+tpow3*t_der23);
discrete Real tpow5_der23(start = tpow4_der23*t+tpow4*t_der23);
discrete Real H0_der23(start = 15*tpow4_der23-10*tpow3_der23-6*tpow5_der23);
discrete Real H1_der23(start = t_der23-6*tpow3_der23+8*tpow4_der23-3*tpow5_der23);
discrete Real H2_der23(start = 0.5*(tpow2_der23-3*tpow3_der23+3*tpow4_der23-tpow5_der23));
discrete Real H3_der23(start = 0.5*tpow3_der23-tpow4_der23+0.5*tpow5_der23);
discrete Real H4_der23(start = 7*tpow4_der23-4*tpow3_der23-3*tpow5_der23);
discrete Real H5_der23(start =  -H0_der23);
public 
algorithm 
y_der23 := H0_der23*y1+H0*y1_der23+(H1_der23*y1d+H1*y1d_der23)*h+H1*y1d*h_der23+(H2_der23*y1dd+H2*y1dd_der23)*hpow2+H2*y1dd*hpow2_der23+(H3_der23*y2dd+H3*y2dd_der23)*hpow2+H3*y2dd*hpow2_der23+(H4_der23*y2d+H4*y2d_der23)*h+H4*y2d*h_der23+H5_der23*y2+H5*y2_der23;
annotation(smoothOrder=98);
end AixLib.Utilities.Math.Functions.quinticHermite:derf;

  */
DYMOLA_STATIC double   AixLib_Utilities_Math_Functions_quinticHermite__derf(
  double  x0_0, double  x10_0, double  x20_0, double  y10_0, double  y20_0, 
  double  y1d0_0, double  y2d0_0, double  y1dd0_0, double  y2dd0_0, double  
  xx_0der23, double  x1x_0der23, double  x2x_0der23, double  y1x_0der23, double 
   y2x_0der23, double  y1dx_0der23, double  y2dx_0der23, double  y1ddx_0der23, 
  double  y2ddx_0der23) {
  PushContext("AixLib.Utilities.Math.Functions.quinticHermite:derf")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   h0_0;
    double   hpow20_0;
    double   t0_0;
    double   tpow20_0;
    double   tpow30_0;
    double   tpow40_0;
    double   tpow50_0;
    double   H00_0;
    double   H10_0;
    double   H20_0;
    double   H30_0;
    double   H40_0;
    double   H50_0;
    double   yx_0der23;
    double   hx_0der23;
    double   hpow2x_0der23;
    double   tx_0der23;
    double   tpow2x_0der23;
    double   tpow3x_0der23;
    double   tpow4x_0der23;
    double   tpow5x_0der23;
    double   H0x_0der23;
    double   H1x_0der23;
    double   H2x_0der23;
    double   H3x_0der23;
    double   H4x_0der23;
    double   H5x_0der23;
    y0_0=0;
    h0_0 = x20_0-x10_0;
    hpow20_0 = h0_0*h0_0;
    t0_0 = divmacro(x0_0-x10_0,"x-x1",h0_0,"h");
    tpow20_0 = t0_0*t0_0;
    tpow30_0 = tpow20_0*t0_0;
    tpow40_0 = tpow30_0*t0_0;
    tpow50_0 = tpow40_0*t0_0;
    H00_0 = 1.0+15*tpow40_0-10*tpow30_0-6*tpow50_0;
    H10_0 = t0_0-6*tpow30_0+8*tpow40_0-3*tpow50_0;
    H20_0 = 0.5*(tpow20_0-3*tpow30_0+3*tpow40_0-tpow50_0);
    H30_0 = 0.5*tpow30_0-tpow40_0+0.5*tpow50_0;
    H40_0 = 7*tpow40_0-4*tpow30_0-3*tpow50_0;
    H50_0 = 1-H00_0;
    yx_0der23=0;
    hx_0der23 = x2x_0der23-x1x_0der23;
    hpow2x_0der23 = 2.0*hx_0der23*h0_0;
    tx_0der23 = divmacro(xx_0der23-x1x_0der23,"x_der23-x1_der23",h0_0,"h")-
      divmacro((x0_0-x10_0)*hx_0der23,"(x-x1)*h_der23",sqr(h0_0),"h^2");
    tpow2x_0der23 = 2.0*tx_0der23*t0_0;
    tpow3x_0der23 = tpow2x_0der23*t0_0+tpow20_0*tx_0der23;
    tpow4x_0der23 = tpow3x_0der23*t0_0+tpow30_0*tx_0der23;
    tpow5x_0der23 = tpow4x_0der23*t0_0+tpow40_0*tx_0der23;
    H0x_0der23 = 15*tpow4x_0der23-10*tpow3x_0der23-6*tpow5x_0der23;
    H1x_0der23 = tx_0der23-6*tpow3x_0der23+8*tpow4x_0der23-3*tpow5x_0der23;
    H2x_0der23 = 0.5*(tpow2x_0der23-3*tpow3x_0der23+3*tpow4x_0der23-
      tpow5x_0der23);
    H3x_0der23 = 0.5*tpow3x_0der23-tpow4x_0der23+0.5*tpow5x_0der23;
    H4x_0der23 = 7*tpow4x_0der23-4*tpow3x_0der23-3*tpow5x_0der23;
    H5x_0der23 =  -H0x_0der23;
    /* Start of real code */
      yx_0der23 = H0x_0der23*y10_0+H00_0*y1x_0der23+(H1x_0der23*y1d0_0+H10_0*
        y1dx_0der23)*h0_0+H10_0*y1d0_0*hx_0der23+(H2x_0der23*y1dd0_0+H20_0*
        y1ddx_0der23)*hpow20_0+H20_0*y1dd0_0*hpow2x_0der23+(H3x_0der23*y2dd0_0+
        H30_0*y2ddx_0der23)*hpow20_0+H30_0*y2dd0_0*hpow2x_0der23+(H4x_0der23*
        y2d0_0+H40_0*y2dx_0der23)*h0_0+H40_0*y2d0_0*hx_0der23+H5x_0der23*y20_0+
        H50_0*y2x_0der23;
    /* Output section */
    PopContext()
    return yx_0der23;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.checkBoundary
input String mediumName;
input String substanceNames[:] "Names of substances";
input Boolean singleState;
input Boolean define_p;
discrete input Real X_boundary[:];
input String modelName(start = "??? boundary ???");
protected 
Integer nX(start = size(X_boundary, 1));
String X_str;
public 
algorithm 
assert( not singleState or singleState and define_p, "
Wrong value of parameter define_p (= false) in model \""+modelName+"\":
The selected medium \""+mediumName+"\" has Medium.singleState=true.
Therefore, an boundary density cannot be defined and
define_p = true is required.
");
for i in (1:nX) loop
assert(X_boundary[i] >= 0.0, "
Wrong boundary mass fractions in medium \""+mediumName+"\" in model \""+modelName+"\":
The boundary value X_boundary("+       String(i, true, 0)+") = "+       String(X_boundary[i], true, 0)+"
is negative. It must be positive.
");
end for;
if (nX > 0 and abs(sum(X_boundary)-1.0) > 1E-10) then 
X_str := "";
for i in (1:nX) loop
X_str := X_str+"   X_boundary["+       String(i, true, 0)+"] = "+       String(X_boundary[i], true, 0)+" \""+substanceNames[i]+"\"\n";
end for;
ModelicaError("The boundary mass fractions in medium \""+mediumName+"\" in model \""+modelName+"\"\n"+"do not sum up to 1. Instead, sum(X_boundary) = "+       String(sum(X_boundary), true, 0)+":\n"+X_str);
end if;
end Modelica.Fluid.Utilities.checkBoundary;

  */
DYMOLA_STATIC void Modelica_Fluid_Utilities_checkBoundary(const char*  
  mediumName0_0, StringArray   substanceNames0_0, int  singleState0_0, int  
  definex_0p, RealArray   Xx_0boundary, const char*  modelName0_0) {
  char*retSMark_=GetStringMark();
  PushContext("Modelica.Fluid.Utilities.checkBoundary")
  {
    /* Declare outputs and temporaries */
    int   nX0_0;
    const char*   Xx_0str;
    MarkObject retmark_ = PushMark();
    nX0_0 = DYNSizeSimple(Xx_0boundary, 1);
    Xx_0str="";
    /* Start of real code */
      AssertModelica( NOT singleState0_0 OR singleState0_0 AND definex_0p,
        " not singleState or singleState and define_p", StringAdd(StringAdd(
        StringAdd(StringAdd("\nWrong value of parameter define_p (= false) in model \"",
        modelName0_0),"\":\nThe selected medium \""),mediumName0_0),
        "\" has Medium.singleState=true.\nTherefore, an boundary density cannot be defined and\ndefine_p = true is required.\n"));
      {
        int end_ = nX0_0;
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          AssertModelica(RealElement( Xx_0boundary, (SizeType)(i0_0_0)) >= 0.0,
            "X_boundary[i] >= 0.0", StringAdd(StringAdd(StringAdd(StringAdd(
            StringAdd(StringAdd(StringAdd(StringAdd("\nWrong boundary mass fractions in medium \"",
            mediumName0_0),"\" in model \""),modelName0_0),"\":\nThe boundary value X_boundary("),
            Integer2String2(i0_0_0, true, 0)),") = "),Real2String2(RealElement( 
            Xx_0boundary, (SizeType)(i0_0_0)), true, 0)),"\nis negative. It must be positive.\n"));
        }
      }
      if (nX0_0 > 0 AND fabs(Realsum( Xx_0boundary)-1.0) > 1E-10) {
        Xx_0str = SqueezeString("", retSMark_);
        Release();
        {
          int end_ = nX0_0;
          int i0_0_0;
          for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
            Xx_0str = SqueezeString(StringAdd(StringAdd(StringAdd(StringAdd(
              StringAdd(StringAdd(StringAdd(Xx_0str,"   X_boundary["),
              Integer2String2(i0_0_0, true, 0)),"] = "),Real2String2(
              RealElement( Xx_0boundary, (SizeType)(i0_0_0)), true, 0))," \""),
              StringElement( substanceNames0_0, (SizeType)(i0_0_0))),"\"\n"), retSMark_);
          }
        }
        ModelicaError(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
          StringAdd(StringAdd(StringAdd("The boundary mass fractions in medium \"",
          mediumName0_0),"\" in model \""),modelName0_0),"\"\n"),
          "do not sum up to 1. Instead, sum(X_boundary) = "),Real2String2(
          Realsum( Xx_0boundary), true, 0)),":\n"),Xx_0str));
        Release();
      }
    /* Output section */
    PopMark(retmark_);
    SetStringMark(retSMark_);
    PopContext()
    return ;
  }}
/* DSblock C-code: */

  BreakSectionDef(1);
#define NX_    0
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    144
#define NP_    50
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   1
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ -886526609
#define NHash2_ -1879275648
#define NHash3_ 0
#define NI_    0
#define NRelF_ 3
#define NRel_  3
#define NTim_  4
#define NSamp_ 0
#define NCons_ 0
#define NA_    58
#define SizePre_ 0
#define SizeEq_ 1
#define SizeDelay_ 0
#define QNLmax_ 2
#define MAXAux 0
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 95
#define NGlobalHelpI_ 46
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="AixLib.Fluid.Actuators.Valves.Examples.TwoWayValvePressureIndependent";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=0;
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,1) = 3;
DYNX(W_,2) = false;
DYNX(W_,8) = 3;
DYNX(W_,10) = true;
DYNX(W_,11) = false;
DYNX(W_,12) = false;
DYNX(W_,13) = false;
DYNX(W_,14) = false;
DYNX(W_,15) = 3;
DYNX(W_,16) = false;
DYNX(W_,18) = 3;
DYNX(W_,20) = false;
DYNX(W_,21) = false;
DYNX(W_,22) = false;
DYNX(W_,23) = false;
DYNX(W_,24) = false;
DYNX(W_,25) = true;
DYNX(W_,26) = 1;
DYNX(W_,28) = false;
DYNX(W_,38) = 1;
DYNX(W_,40) = 1;
DYNX(W_,41) = 1;
DYNX(W_,46) = false;
DYNX(W_,52) = 0;
DYNX(W_,65) = true;
DYNX(W_,66) = 1;
DYNX(W_,68) = false;
DYNX(W_,78) = 1;
DYNX(W_,80) = 1;
DYNX(W_,85) = false;
DYNX(W_,92) = 0;
DYNX(W_,105) = true;
DYNX(W_,106) = 1;
DYNX(W_,108) = false;
DYNX(W_,118) = 1;
DYNX(W_,120) = 1;
DYNX(W_,125) = false;
DYNX(W_,131) = 0;
DYNX(W_,27) = 0.0001;
DYNX(W_,30) = 0;
DYNX(W_,31) = 0;
DYNX(W_,32) = true;
DYNX(W_,34) = true;
DYNX(W_,35) = false;
DYNX(W_,37) = 0.001;
DYNX(W_,67) = 0.0001;
DYNX(W_,70) = 0;
DYNX(W_,71) = 0;
DYNX(W_,72) = true;
DYNX(W_,74) = true;
DYNX(W_,75) = false;
DYNX(W_,77) = 0.001;
DYNX(W_,107) = 0.0001;
DYNX(W_,110) = 0;
DYNX(W_,111) = 0;
DYNX(W_,112) = false;
DYNX(W_,114) = true;
DYNX(W_,115) = false;
DYNX(W_,117) = 0.001;
DYNX(W_,47) = 0;
DYNX(W_,86) = 5000;
DYNX(W_,126) = 0;
memcpy(&DYNX(W_,56), &DymArrays0, sizeof(double)*5);
DYNX(W_,64) = 0;
memcpy(&DYNX(W_,96), &DymArrays0, sizeof(double)*5);
DYNX(W_,104) = 0;
memcpy(&DYNX(W_,133), &DymArrays1, sizeof(double)*3);
memcpy(&DYNX(W_,140), &DymArrays1, sizeof(double)*3);
DYNX(W_,19) = 1.0;
DYNX(W_,9) = 1.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
DYNX(W_,33) = DYNX(DP_,13)+DYNX(W_,47);
DYNX(W_,36) = DYNX(DP_,12);
DYNX(W_,39) = fabs(DYNX(W_,33));
DYNX(W_,49) = IF DYNX(W_,47) > 1E-15 THEN divmacro(1,"1",sqrtGuarded(DYNX(W_,47),
  "valInd.dpFixed_nominal"),"sqrt(valInd.dpFixed_nominal)") ELSE 0;
DYNX(W_,50) = divmacro(DYNX(DP_,20),"valInd.l2",DYNX(W_,33),"valInd.dp_nominal");
DYNX(W_,51) = divmacro(1,"1",DYNX(W_,50),"valInd.coeff1");
DYNX(W_,73) = DYNX(DP_,29)+DYNX(W_,86);
DYNX(W_,76) = DYNX(DP_,28);
DYNX(W_,79) = fabs(DYNX(W_,73));
DYNX(W_,88) = IF DYNX(W_,86) > 1E-15 THEN divmacro(1,"1",sqrtGuarded(DYNX(W_,86),
  "valIndDpFix.dpFixed_nominal"),"sqrt(valIndDpFix.dpFixed_nominal)") ELSE 0;
DYNX(W_,90) = divmacro(DYNX(DP_,36),"valIndDpFix.l2",DYNX(W_,73),
  "valIndDpFix.dp_nominal");
DYNX(W_,91) = divmacro(1,"1",DYNX(W_,90),"valIndDpFix.coeff1");
DYNX(W_,113) = DYNX(DP_,41)+DYNX(W_,126);
DYNX(W_,116) = DYNX(DP_,40);
DYNX(W_,119) = fabs(DYNX(W_,113));
DYNX(W_,128) = IF DYNX(W_,126) > 1E-15 THEN divmacro(1,"1",sqrtGuarded(
  DYNX(W_,126),"valIndFromMflow.dpFixed_nominal"),"sqrt(valIndFromMflow.dpFixed_nominal)")
   ELSE 0;
DYNX(W_,129) = divmacro(DYNX(DP_,48),"valIndFromMflow.l2",DYNX(W_,113),
  "valIndFromMflow.dp_nominal");
DYNX(W_,130) = divmacro(1,"1",DYNX(W_,129),"valIndFromMflow.coeff1");
BoundParameterConstantSection
DYNX(W_,5) = 4184*(DYNX(DP_,5)-273.15);
DYNX(W_,17) = 4184*(DYNX(DP_,8)-273.15);
BoundParameterSection
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,3) = 0;
DYNX(W_,4) = 300000;
DYNX(W_,6) = 0;
DYNX(W_,7) = 0;
DYNX(W_,29) = 0;
DYNX(W_,69) = 0;
DYNX(W_,109) = 0;
#endif
InitialSection
InitialStartSection
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
DYNX(W_,33) = DYNX(DP_,13)+DYNX(W_,47);
DYNX(W_,36) = DYNX(DP_,12);
DYNX(W_,39) = fabs(DYNX(W_,33));
DYNX(W_,49) = IF DYNX(W_,47) > 1E-15 THEN divmacro(1,"1",sqrtGuarded(DYNX(W_,47),
  "valInd.dpFixed_nominal"),"sqrt(valInd.dpFixed_nominal)") ELSE 0;
DYNX(W_,50) = divmacro(DYNX(DP_,20),"valInd.l2",DYNX(W_,33),"valInd.dp_nominal");
DYNX(W_,51) = divmacro(1,"1",DYNX(W_,50),"valInd.coeff1");
DYNX(W_,73) = DYNX(DP_,29)+DYNX(W_,86);
DYNX(W_,76) = DYNX(DP_,28);
DYNX(W_,79) = fabs(DYNX(W_,73));
DYNX(W_,88) = IF DYNX(W_,86) > 1E-15 THEN divmacro(1,"1",sqrtGuarded(DYNX(W_,86),
  "valIndDpFix.dpFixed_nominal"),"sqrt(valIndDpFix.dpFixed_nominal)") ELSE 0;
DYNX(W_,90) = divmacro(DYNX(DP_,36),"valIndDpFix.l2",DYNX(W_,73),
  "valIndDpFix.dp_nominal");
DYNX(W_,91) = divmacro(1,"1",DYNX(W_,90),"valIndDpFix.coeff1");
DYNX(W_,113) = DYNX(DP_,41)+DYNX(W_,126);
DYNX(W_,116) = DYNX(DP_,40);
DYNX(W_,119) = fabs(DYNX(W_,113));
DYNX(W_,128) = IF DYNX(W_,126) > 1E-15 THEN divmacro(1,"1",sqrtGuarded(
  DYNX(W_,126),"valIndFromMflow.dpFixed_nominal"),"sqrt(valIndFromMflow.dpFixed_nominal)")
   ELSE 0;
DYNX(W_,129) = divmacro(DYNX(DP_,48),"valIndFromMflow.l2",DYNX(W_,113),
  "valIndFromMflow.dp_nominal");
DYNX(W_,130) = divmacro(1,"1",DYNX(W_,129),"valIndFromMflow.coeff1");
DYNX(W_,45) = divmacro(1,"1",sqrtGuarded(DYNX(DP_,13),"valInd.dpValve_nominal"),
  "sqrt(valInd.dpValve_nominal)");
DYNX(W_,42) = divmacro(DYNX(W_,45),"valInd.Kv_SI",8.78410461157883E-07*
  DYNX(DP_,14),"8.78410461157883E-07*valInd.rhoStd");
DYNX(W_,43) = divmacro(DYNX(W_,45),"valInd.Kv_SI",1.2042949486827428E-05*
  DYNX(DP_,14)*0.0631,"1.2042949486827428E-05*(valInd.rhoStd*0.0631)");
DYNX(W_,44) = divmacro(DYNX(W_,45),"valInd.Kv_SI",sqrtGuarded(DYNX(DP_,14),
  "valInd.rhoStd"),"sqrt(valInd.rhoStd)");
DYNX(W_,84) = divmacro(1,"1",sqrtGuarded(DYNX(DP_,29),"valIndDpFix.dpValve_nominal"),
  "sqrt(valIndDpFix.dpValve_nominal)");
DYNX(W_,81) = divmacro(DYNX(W_,84),"valIndDpFix.Kv_SI",8.78410461157883E-07*
  DYNX(DP_,30),"8.78410461157883E-07*valIndDpFix.rhoStd");
DYNX(W_,82) = divmacro(DYNX(W_,84),"valIndDpFix.Kv_SI",1.2042949486827428E-05*
  DYNX(DP_,30)*0.0631,"1.2042949486827428E-05*(valIndDpFix.rhoStd*0.0631)");
DYNX(W_,83) = divmacro(DYNX(W_,84),"valIndDpFix.Kv_SI",sqrtGuarded(DYNX(DP_,30),
  "valIndDpFix.rhoStd"),"sqrt(valIndDpFix.rhoStd)");
DYNX(W_,124) = divmacro(1,"1",sqrtGuarded(DYNX(DP_,41),"valIndFromMflow.dpValve_nominal"),
  "sqrt(valIndFromMflow.dpValve_nominal)");
DYNX(W_,121) = divmacro(DYNX(W_,124),"valIndFromMflow.Kv_SI",8.78410461157883E-07
  *DYNX(DP_,42),"8.78410461157883E-07*valIndFromMflow.rhoStd");
DYNX(W_,122) = divmacro(DYNX(W_,124),"valIndFromMflow.Kv_SI",1.2042949486827428E-05
  *DYNX(DP_,42)*0.0631,"1.2042949486827428E-05*(valIndFromMflow.rhoStd*0.0631)");
DYNX(W_,123) = divmacro(DYNX(W_,124),"valIndFromMflow.Kv_SI",sqrtGuarded(
  DYNX(DP_,42),"valIndFromMflow.rhoStd"),"sqrt(valIndFromMflow.rhoStd)");
DYNX(W_,89) = sqrtGuarded(divmacro(1,"1",divmacro(1,"1",sqr(DYNX(W_,88)),
  "valIndDpFix.kFixed^2")+divmacro(1,"1",sqr(DYNX(W_,84)),"valIndDpFix.Kv_SI^2"),
  "1/valIndDpFix.kFixed^2+1/valIndDpFix.Kv_SI^2"),"1/(1/valIndDpFix.kFixed^2+1/valIndDpFix.Kv_SI^2)");
DYNX(W_,5) = 4184*(DYNX(DP_,5)-273.15);
DYNX(W_,17) = 4184*(DYNX(DP_,8)-273.15);
DYNX(W_,0) = DYNX(DP_,2)+(IF LessTime(DYNX(DP_,3), 0) THEN 0 ELSE IF LessTime(
  DYNX(DP_,3)+DYNX(DP_,1), 1) THEN divmacro((DYNTime-DYNX(DP_,3))*DYNX(DP_,0),
  "(time-y.startTime)*y.height",DYNX(DP_,1),"y.duration") ELSE DYNX(DP_,0));
DYNX(W_,48) = DYNX(DP_,19)+DYNX(W_,0)*(1-DYNX(DP_,19));
AssertModelica(Greater(DYNX(W_,48),"valInd.phi", -0.2,"-0.2", 0),
  "valInd.phi > -0.2", StringAdd("Valve control signal needs to be bigger than zero, received phi = ",
  Real2String2(DYNX(W_,48), true, 0)));
PopAllMarks();
DYNX(W_,87) = DYNX(DP_,35)+DYNX(W_,0)*(1-DYNX(DP_,35));
AssertModelica(Greater(DYNX(W_,87),"valIndDpFix.phi", -0.2,"-0.2", 1),
  "valIndDpFix.phi > -0.2", StringAdd("Valve control signal needs to be bigger than zero, received phi = ",
  Real2String2(DYNX(W_,87), true, 0)));
PopAllMarks();
DYNX(W_,127) = DYNX(DP_,47)+DYNX(W_,0)*(1-DYNX(DP_,47));
AssertModelica(Greater(DYNX(W_,127),"valIndFromMflow.phi", -0.2,"-0.2", 2),
  "valIndFromMflow.phi > -0.2", StringAdd("Valve control signal needs to be bigger than zero, received phi = ",
  Real2String2(DYNX(W_,127), true, 0)));
PopAllMarks();
DYNX(W_,4) = DYNX(DP_,24)+(IF LessTime(DYNX(DP_,25), 2) THEN 0 ELSE IF LessTime(
  DYNX(DP_,25)+DYNX(DP_,23), 3) THEN divmacro((DYNTime-DYNX(DP_,25))*
  DYNX(DP_,22),"(time-dp.startTime)*dp.height",DYNX(DP_,23),"dp.duration") ELSE 
  DYNX(DP_,22));
DYNX(W_,29) = DYNX(W_,4)-DYNX(DP_,7);
DYNX(W_,53) = (PushModelContext(1,"AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(valInd.phi, valInd.Kv_SI, valInd.m_flow_turbulent)")
  AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(DYNX(W_,48), 
  DYNX(W_,45), DYNX(W_,36)));
PopModelContext();
DYNX(W_,54) = DYNX(W_,29)-DYNX(W_,53);
DYNX(W_,55) =  -DYNX(DP_,21)*DYNX(W_,53);
DYNX(W_,62) = (PushModelContext(1,"AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(min(valInd.dp, valInd.dp_min+valInd.dp_x1), valInd.Kv_SI, valInd.m_flow_turbulent)")
  AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp(RealBmin(
  DYNX(W_,29), DYNX(W_,53)+DYNX(W_,55)), DYNX(W_,45), DYNX(W_,36)));
PopModelContext();
DYNX(W_,61) = DYNX(W_,48)+DYNX(W_,50)*RealBmax(DYNX(W_,54),  -DYNX(W_,55));
DYNX(W_,63) = IF DYNX(W_,54) <= DYNX(W_,55) THEN DYNX(W_,62) ELSE IF DYNX(W_,54)
   >=  -DYNX(W_,55) THEN DYNX(W_,61) ELSE (PushModelContext(1,"AixLib.Utilities.Math.Functions.quinticHermite(valInd.dp_x, valInd.dp_x1,  -valInd.dp_x1, valInd.m_flow_y1, valInd.m_flow_y2, AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der(valInd.dp_min+valInd.dp_x1, valInd.Kv_SI, valInd.m_flow_turbulent, 1), valInd.coeff1, AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der2(valInd.dp_min+valInd.dp_x1, valInd.Kv_SI, valInd.m_flow_turbul...")
  AixLib_Utilities_Math_Functions_quinticHermite(DYNX(W_,54), DYNX(W_,55),  -
  DYNX(W_,55), DYNX(W_,62), DYNX(W_,61), AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dpx_0der
  (DYNX(W_,53)+DYNX(W_,55), DYNX(W_,45), DYNX(W_,36), 1), DYNX(W_,50), 
  AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dpx_0der2(DYNX(W_,53)+
  DYNX(W_,55), DYNX(W_,45), DYNX(W_,36), 1, 0), 0));
PopModelContext();
DYNX(W_,3) =  -homotopy(DYNX(W_,63), divmacro(DYNX(W_,29),"valInd.dp",
  DYNX(W_,39),"valInd.dp_nominal_pos"));
DYNX(W_,69) = DYNX(W_,4)-DYNX(DP_,7);
DYNX(W_,93) = (PushModelContext(1,"AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(valIndDpFix.phi, valIndDpFix.k, valIndDpFix.m_flow_turbulent)")
  AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(DYNX(W_,87), 
  DYNX(W_,89), DYNX(W_,76)));
PopModelContext();
DYNX(W_,94) = DYNX(W_,69)-DYNX(W_,93);
DYNX(W_,95) =  -DYNX(DP_,37)*DYNX(W_,93);
DYNX(W_,102) = (PushModelContext(1,"AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(min(valIndDpFix.dp, valIndDpFix.dp_min+valIndDpFix.dp_x1), valIndDpFix.k, valIndDpFix.m_flow_turbulent)")
  AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp(RealBmin(
  DYNX(W_,69), DYNX(W_,93)+DYNX(W_,95)), DYNX(W_,89), DYNX(W_,76)));
PopModelContext();
DYNX(W_,101) = DYNX(W_,87)+DYNX(W_,90)*RealBmax(DYNX(W_,94),  -DYNX(W_,95));
DYNX(W_,103) = IF DYNX(W_,94) <= DYNX(W_,95) THEN DYNX(W_,102) ELSE IF 
  DYNX(W_,94) >=  -DYNX(W_,95) THEN DYNX(W_,101) ELSE (PushModelContext(1,
  "AixLib.Utilities.Math.Functions.quinticHermite(valIndDpFix.dp_x, valIndDpFix.dp_x1,  -valIndDpFix.dp_x1, valIndDpFix.m_flow_y1, valIndDpFix.m_flow_y2, AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der(valIndDpFix.dp_min+valIndDpFix.dp_x1, valIndDpFix.k, valIndDpFix.m_flow_turbulent, 1), valIndDpFix.coeff1, AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der2(valIndDpFix.dp_m...")
  AixLib_Utilities_Math_Functions_quinticHermite(DYNX(W_,94), DYNX(W_,95),  -
  DYNX(W_,95), DYNX(W_,102), DYNX(W_,101), AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dpx_0der
  (DYNX(W_,93)+DYNX(W_,95), DYNX(W_,89), DYNX(W_,76), 1), DYNX(W_,90), 
  AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dpx_0der2(DYNX(W_,93)+
  DYNX(W_,95), DYNX(W_,89), DYNX(W_,76), 1, 0), 0));
PopModelContext();
DYNX(W_,6) =  -homotopy(DYNX(W_,103), divmacro(DYNX(W_,69),"valIndDpFix.dp",
  DYNX(W_,79),"valIndDpFix.dp_nominal_pos"));
DYNX(W_,109) = DYNX(W_,4)-DYNX(DP_,7);
DYNX(W_,139) =  -DYNX(DP_,49)*DYNX(W_,127);
DYNX(W_,132) = (PushModelContext(1,"AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(valIndFromMflow.phi, valIndFromMflow.Kv_SI, valIndFromMflow.m_flow_turbulent)")
  AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(DYNX(W_,127),
   DYNX(W_,124), DYNX(W_,116)));
PopModelContext();
if (DymolaHomotopyLambda==0){
  BreakSectionCallNew(1);
}
else {

  { /* Non-linear system of equations to solve. */
  /* Tag: initialization.nonlinear[1] */
  /* Introducing 7 common subexpressions used in 16 expressions */
  /* Of the common subexpressions 5 are reals, 0 are integers, and 2
     are booleans. */
  const char*const varnames_[]={"sou.ports[3].m_flow"};
  const double nominal_[]={1.0};
  NonLinearSystemOfEquations(Jacobian__, residue__, x__, 1, 0, 1, -2, 
    DYNX(DYNhelp,0), 35, DYNX(did_->helpvari_vec,0), 23);
  SetInitVectorSimple(x__, 1, DYNX(W_,7), 0, 0);
  Residues;
    DYNX(DYNhelp,35) =  -DYNX(W_,7);
    DYNX(DYNhelp,36) = DYNX(W_,127)+DYNX(W_,139);
    DYNX(DYNhelp,37) = RealBmin(DYNX(DYNhelp,35), DYNX(DYNhelp,36));
    DYNX(W_,137) = (PushModelContext(1,"AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(min( -sou.ports[3].m_flow, valIndFromMflow.phi+valIndFromMflow.m_flow_x1), valIndFromMflow.Kv_SI, valIndFromMflow.m_flow_turbulent)")
      AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(
      DYNX(DYNhelp,37), DYNX(W_,124), DYNX(W_,116)));
    PopModelContext();
    DYNX(W_,138) =  -(DYNX(W_,7)+DYNX(W_,127));
    DYNX(DYNhelp,38) =  -DYNX(W_,139);
    DYNX(W_,136) = DYNX(W_,132)+DYNX(W_,130)*RealBmax(DYNX(W_,138), 
      DYNX(DYNhelp,38));
    DYNX(DYNhelp,39) = DYNX(W_,138) <= DYNX(W_,139);
    DYNX(W_,143) = IF DYNX(DYNhelp,39) THEN DYNX(W_,137) ELSE IF DYNX(W_,138)
       >= DYNX(DYNhelp,38) THEN DYNX(W_,136) ELSE (PushModelContext(1,
      "AixLib.Utilities.Math.Functions.quinticHermite(valIndFromMflow.m_flow_x, valIndFromMflow.m_flow_x1,  -valIndFromMflow.m_flow_x1, valIndFromMflow.dp_y1, valIndFromMflow.dp_y2, AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der(valIndFromMflow.phi+valIndFromMflow.m_flow_x1, valIndFromMflow.Kv_SI, valIndFromMflow.m_flow_turbulent, 1), valIndFromMflow.coeff2, AixLib.Fluid.BaseClasses....")
      AixLib_Utilities_Math_Functions_quinticHermite(DYNX(W_,138), DYNX(W_,139),
       DYNX(DYNhelp,38), DYNX(W_,137), DYNX(W_,136), AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der
      (DYNX(DYNhelp,36), DYNX(W_,124), DYNX(W_,116), 1), DYNX(W_,130), 
      AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der2(
      DYNX(DYNhelp,36), DYNX(W_,124), DYNX(W_,116), 1, 0), 0));
    PopModelContext();
  SetVector(residue__, 1, DYNX(W_,109)-homotopy(DYNX(W_,143),  -DYNX(W_,119)*
    DYNX(W_,7)));

  Jacobian(Jacobian__)
  MatrixZeros(Jacobian__);
  DYNX(DYNhelp,40) = DYNX(W_,138) > DYNX(DYNhelp,38);
  DYNX(DYNhelp,41) = homotopy(1.0, 0.0);
  SetMatrixLeading(Jacobian__, 1, 1, 1, DYNX(W_,130)*(IF DYNX(DYNhelp,40) THEN 
    1.0 ELSE 0.0)*(IF DYNX(DYNhelp,39) THEN 0.0 ELSE IF DYNX(W_,138) >= 
    DYNX(DYNhelp,38) THEN 1.0 ELSE (PushModelContext(1,"AixLib.Utilities.Math.Functions.quinticHermite:derf(valIndFromMflow.m_flow_x, valIndFromMflow.m_flow_x1,  -valIndFromMflow.m_flow_x1, valIndFromMflow.dp_y1, valIndFromMflow.dp_y2, AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der(valIndFromMflow.phi+valIndFromMflow.m_flow_x1, valIndFromMflow.Kv_SI, valIndFromMflow.m_flow_turbulent, 1), valIndFromMflow.coeff2, AixLib.Fluid.BaseCla...")
    AixLib_Utilities_Math_Functions_quinticHermite__derf(DYNX(W_,138), 
    DYNX(W_,139), DYNX(DYNhelp,38), DYNX(W_,137), DYNX(W_,136), AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der
    (DYNX(DYNhelp,36), DYNX(W_,124), DYNX(W_,116), 1), DYNX(W_,130), 
    AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der2(
    DYNX(DYNhelp,36), DYNX(W_,124), DYNX(W_,116), 1, 0), 0, 0.0, 0.0, 0.0, 0.0, 
    1.0, 0.0, 0.0, 0.0, 0)))*DYNX(DYNhelp,41)+(IF DYNX(DYNhelp,39) THEN 0.0
     ELSE IF DYNX(W_,138) >= DYNX(DYNhelp,38) THEN 0.0 ELSE (PushModelContext(1,
    "AixLib.Utilities.Math.Functions.quinticHermite:derf(valIndFromMflow.m_flow_x, valIndFromMflow.m_flow_x1,  -valIndFromMflow.m_flow_x1, valIndFromMflow.dp_y1, valIndFromMflow.dp_y2, AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der(valIndFromMflow.phi+valIndFromMflow.m_flow_x1, valIndFromMflow.Kv_SI, valIndFromMflow.m_flow_turbulent, 1), valIndFromMflow.coeff2, AixLib.Fluid.BaseCla...")
    AixLib_Utilities_Math_Functions_quinticHermite__derf(DYNX(W_,138), 
    DYNX(W_,139), DYNX(DYNhelp,38), DYNX(W_,137), DYNX(W_,136), AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der
    (DYNX(DYNhelp,36), DYNX(W_,124), DYNX(W_,116), 1), DYNX(W_,130), 
    AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der2(
    DYNX(DYNhelp,36), DYNX(W_,124), DYNX(W_,116), 1, 0), 0, 1.0, 0.0, 0.0, 0.0, 
    0.0, 0.0, 0.0, 0.0, 0)))*DYNX(DYNhelp,41)-(IF DYNX(DYNhelp,39) THEN 1.0
     ELSE IF DYNX(W_,138) >= DYNX(DYNhelp,38) THEN 0.0 ELSE (PushModelContext(1,
    "AixLib.Utilities.Math.Functions.quinticHermite:derf(valIndFromMflow.m_flow_x, valIndFromMflow.m_flow_x1,  -valIndFromMflow.m_flow_x1, valIndFromMflow.dp_y1, valIndFromMflow.dp_y2, AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der(valIndFromMflow.phi+valIndFromMflow.m_flow_x1, valIndFromMflow.Kv_SI, valIndFromMflow.m_flow_turbulent, 1), valIndFromMflow.coeff2, AixLib.Fluid.BaseCla...")
    AixLib_Utilities_Math_Functions_quinticHermite__derf(DYNX(W_,138), 
    DYNX(W_,139), DYNX(DYNhelp,38), DYNX(W_,137), DYNX(W_,136), AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der
    (DYNX(DYNhelp,36), DYNX(W_,124), DYNX(W_,116), 1), DYNX(W_,130), 
    AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der2(
    DYNX(DYNhelp,36), DYNX(W_,124), DYNX(W_,116), 1, 0), 0, 0.0, 0.0, 0.0, 1.0, 
    0.0, 0.0, 0.0, 0.0, 0)))*DYNX(DYNhelp,41)*(PushModelContext(1,
    "AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der(min( -sou.ports[3].m_flow, valIndFromMflow.phi+valIndFromMflow.m_flow_x1), valIndFromMflow.Kv_SI, valIndFromMflow.m_flow_turbulent, (if noEvent( -sou.ports[3].m_flow < valIndFromMflow.phi+valIndFromMflow.m_flow_x1) then -1.0 else 0.0))")
    AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der(
    DYNX(DYNhelp,37), DYNX(W_,124), DYNX(W_,116), IF DYNX(DYNhelp,35) < 
    DYNX(DYNhelp,36) THEN -1.0 ELSE 0.0))-homotopy(0.0,  -DYNX(W_,119)));
  PopModelContext();

  SolveNonLinearSystemOfEquationsInit(Jacobian__, residue__, x__,"Tag: initialization.nonlinear[1]");
  DYNX(W_,7) = GetVector(x__, 1);
  EndNonLinearSystemOfEquationsInit(residue__, x__, 1);
   /* End of Non-Linear Equation Block */ }



}
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
InitialSection2
(PushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"SimpleLiquidWater\", {\"SimpleLiquidWater\"}, true, true, sou.X_in_internal, \"Boundary_pT\")")
  Modelica_Fluid_Utilities_checkBoundary("SimpleLiquidWater", StringTemporaryDense( 
  DymArrays2, 1, 1), true, true, RealTemporaryDense( &DYNX(W_,9), 1, 1), 
  "Boundary_pT"));
PopAllMarks();
(PushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"SimpleLiquidWater\", {\"SimpleLiquidWater\"}, true, true, sin.X_in_internal, \"Boundary_pT\")")
  Modelica_Fluid_Utilities_checkBoundary("SimpleLiquidWater", StringTemporaryDense( 
  DymArrays2, 1, 1), true, true, RealTemporaryDense( &DYNX(W_,19), 1, 1), 
  "Boundary_pT"));
PopAllMarks();
EndInitialSection

OutputSection

DynamicsSection

AcceptedSection1
DYNX(W_,0) = DYNX(DP_,2)+(IF LessTime(DYNX(DP_,3), 0) THEN 0 ELSE IF LessTime(
  DYNX(DP_,3)+DYNX(DP_,1), 1) THEN divmacro((DYNTime-DYNX(DP_,3))*DYNX(DP_,0),
  "(time-y.startTime)*y.height",DYNX(DP_,1),"y.duration") ELSE DYNX(DP_,0));
DYNX(W_,48) = DYNX(DP_,19)+DYNX(W_,0)*(1-DYNX(DP_,19));
AssertModelica(Greater(DYNX(W_,48),"valInd.phi", -0.2,"-0.2", 0),
  "valInd.phi > -0.2", StringAdd("Valve control signal needs to be bigger than zero, received phi = ",
  Real2String2(DYNX(W_,48), true, 0)));
PopAllMarks();
DYNX(W_,87) = DYNX(DP_,35)+DYNX(W_,0)*(1-DYNX(DP_,35));
AssertModelica(Greater(DYNX(W_,87),"valIndDpFix.phi", -0.2,"-0.2", 1),
  "valIndDpFix.phi > -0.2", StringAdd("Valve control signal needs to be bigger than zero, received phi = ",
  Real2String2(DYNX(W_,87), true, 0)));
PopAllMarks();
DYNX(W_,127) = DYNX(DP_,47)+DYNX(W_,0)*(1-DYNX(DP_,47));
AssertModelica(Greater(DYNX(W_,127),"valIndFromMflow.phi", -0.2,"-0.2", 2),
  "valIndFromMflow.phi > -0.2", StringAdd("Valve control signal needs to be bigger than zero, received phi = ",
  Real2String2(DYNX(W_,127), true, 0)));
PopAllMarks();

AcceptedSection2
DYNX(W_,4) = DYNX(DP_,24)+(IF LessTime(DYNX(DP_,25), 2) THEN 0 ELSE IF LessTime(
  DYNX(DP_,25)+DYNX(DP_,23), 3) THEN divmacro((DYNTime-DYNX(DP_,25))*
  DYNX(DP_,22),"(time-dp.startTime)*dp.height",DYNX(DP_,23),"dp.duration") ELSE 
  DYNX(DP_,22));
DYNX(W_,29) = DYNX(W_,4)-DYNX(DP_,7);
DYNX(W_,53) = (PushModelContext(1,"AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(valInd.phi, valInd.Kv_SI, valInd.m_flow_turbulent)")
  AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(DYNX(W_,48), 
  DYNX(W_,45), DYNX(W_,36)));
PopModelContext();
DYNX(W_,54) = DYNX(W_,29)-DYNX(W_,53);
DYNX(W_,55) =  -DYNX(DP_,21)*DYNX(W_,53);
DYNX(DYNhelp,42) = RealBmin(DYNX(W_,29), DYNX(W_,53)+DYNX(W_,55));
DYNX(W_,62) = (PushModelContext(1,"AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(min(valInd.dp, valInd.dp_min+valInd.dp_x1), valInd.Kv_SI, valInd.m_flow_turbulent)")
  AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp(DYNX(DYNhelp,42), 
  DYNX(W_,45), DYNX(W_,36)));
PopModelContext();
DYNX(DYNhelp,43) = RealBmax(DYNX(W_,54),  -DYNX(W_,55));
DYNX(W_,61) = DYNX(W_,48)+DYNX(W_,50)*DYNX(DYNhelp,43);
DYNX(W_,63) = IF DYNX(W_,54) <= DYNX(W_,55) THEN DYNX(W_,62) ELSE IF DYNX(W_,54)
   >=  -DYNX(W_,55) THEN DYNX(W_,61) ELSE (PushModelContext(1,"AixLib.Utilities.Math.Functions.quinticHermite(valInd.dp_x, valInd.dp_x1,  -valInd.dp_x1, valInd.m_flow_y1, valInd.m_flow_y2, AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der(valInd.dp_min+valInd.dp_x1, valInd.Kv_SI, valInd.m_flow_turbulent, 1), valInd.coeff1, AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der2(valInd.dp_min+valInd.dp_x1, valInd.Kv_SI, valInd.m_flow_turbul...")
  AixLib_Utilities_Math_Functions_quinticHermite(DYNX(W_,54), DYNX(W_,55),  -
  DYNX(W_,55), DYNX(W_,62), DYNX(W_,61), AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dpx_0der
  (DYNX(W_,53)+DYNX(W_,55), DYNX(W_,45), DYNX(W_,36), 1), DYNX(W_,50), 
  AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dpx_0der2(DYNX(W_,53)+
  DYNX(W_,55), DYNX(W_,45), DYNX(W_,36), 1, 0), 0));
PopModelContext();
DYNX(W_,3) =  -DYNX(W_,63);
DYNX(W_,69) = DYNX(W_,4)-DYNX(DP_,7);
DYNX(W_,93) = (PushModelContext(1,"AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(valIndDpFix.phi, valIndDpFix.k, valIndDpFix.m_flow_turbulent)")
  AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(DYNX(W_,87), 
  DYNX(W_,89), DYNX(W_,76)));
PopModelContext();
DYNX(W_,94) = DYNX(W_,69)-DYNX(W_,93);
DYNX(W_,95) =  -DYNX(DP_,37)*DYNX(W_,93);
DYNX(DYNhelp,44) = RealBmin(DYNX(W_,69), DYNX(W_,93)+DYNX(W_,95));
DYNX(W_,102) = (PushModelContext(1,"AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(min(valIndDpFix.dp, valIndDpFix.dp_min+valIndDpFix.dp_x1), valIndDpFix.k, valIndDpFix.m_flow_turbulent)")
  AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp(DYNX(DYNhelp,44), 
  DYNX(W_,89), DYNX(W_,76)));
PopModelContext();
DYNX(DYNhelp,45) = RealBmax(DYNX(W_,94),  -DYNX(W_,95));
DYNX(W_,101) = DYNX(W_,87)+DYNX(W_,90)*DYNX(DYNhelp,45);
DYNX(W_,103) = IF DYNX(W_,94) <= DYNX(W_,95) THEN DYNX(W_,102) ELSE IF 
  DYNX(W_,94) >=  -DYNX(W_,95) THEN DYNX(W_,101) ELSE (PushModelContext(1,
  "AixLib.Utilities.Math.Functions.quinticHermite(valIndDpFix.dp_x, valIndDpFix.dp_x1,  -valIndDpFix.dp_x1, valIndDpFix.m_flow_y1, valIndDpFix.m_flow_y2, AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der(valIndDpFix.dp_min+valIndDpFix.dp_x1, valIndDpFix.k, valIndDpFix.m_flow_turbulent, 1), valIndDpFix.coeff1, AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der2(valIndDpFix.dp_m...")
  AixLib_Utilities_Math_Functions_quinticHermite(DYNX(W_,94), DYNX(W_,95),  -
  DYNX(W_,95), DYNX(W_,102), DYNX(W_,101), AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dpx_0der
  (DYNX(W_,93)+DYNX(W_,95), DYNX(W_,89), DYNX(W_,76), 1), DYNX(W_,90), 
  AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dpx_0der2(DYNX(W_,93)+
  DYNX(W_,95), DYNX(W_,89), DYNX(W_,76), 1, 0), 0));
PopModelContext();
DYNX(W_,6) =  -DYNX(W_,103);
DYNX(W_,109) = DYNX(W_,4)-DYNX(DP_,7);
DYNX(W_,139) =  -DYNX(DP_,49)*DYNX(W_,127);
DYNX(W_,132) = (PushModelContext(1,"AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(valIndFromMflow.phi, valIndFromMflow.Kv_SI, valIndFromMflow.m_flow_turbulent)")
  AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(DYNX(W_,127),
   DYNX(W_,124), DYNX(W_,116)));
PopModelContext();

{ /* Non-linear system of equations to solve. */
/* Tag: simulation.nonlinear[1] */
/* Introducing 22 common subexpressions and reusing 1 variables totally used in 14
   expressions */
/* Of the common subexpressions 20 are reals, 0 are integers, and 3
   are booleans. */
const char*const varnames_[]={"sou.ports[3].m_flow"};
const double nominal_[]={1.0};
NonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 1, 0, 2, -2, 4, 
  DYNX(DYNhelp,46), 43, DYNX(did_->helpvari_vec,23), 23);
NonLinearSystemSave(DYNX(W_,109), 0);
NonLinearSystemSave(DYNX(W_,132), 1);
NonLinearSystemSave(DYNX(W_,139), 2);
NonLinearSystemSave(DYNX(W_,127), 3);
SetInitVectorNH(x__, 1, DYNX(W_,7), Remember_(DYNX(W_,7), 0));
Residues;
  DYNX(DYNhelp,89) =  -DYNX(W_,7);
  DYNX(DYNhelp,90) = DYNX(W_,127)+DYNX(W_,139);
  DYNX(DYNhelp,91) = RealBmin(DYNX(DYNhelp,89), DYNX(DYNhelp,90));
  DYNX(W_,137) = (PushModelContext(1,"AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(min( -sou.ports[3].m_flow, valIndFromMflow.phi+valIndFromMflow.m_flow_x1), valIndFromMflow.Kv_SI, valIndFromMflow.m_flow_turbulent)")
    AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(
    DYNX(DYNhelp,91), DYNX(W_,124), DYNX(W_,116)));
  PopModelContext();
  DYNX(W_,138) =  -(DYNX(W_,7)+DYNX(W_,127));
  DYNX(DYNhelp,92) =  -DYNX(W_,139);
  DYNX(DYNhelp,93) = RealBmax(DYNX(W_,138), DYNX(DYNhelp,92));
  DYNX(W_,136) = DYNX(W_,132)+DYNX(W_,130)*DYNX(DYNhelp,93);
DYNX(DYNhelp,94) = DYNX(W_,138) <= DYNX(W_,139);
SetVector(residue__, 1, DYNX(W_,109)-(IF DYNX(DYNhelp,94) THEN DYNX(W_,137)
   ELSE IF DYNX(W_,138) >= DYNX(DYNhelp,92) THEN DYNX(W_,136) ELSE 
  (PushModelContext(1,"AixLib.Utilities.Math.Functions.quinticHermite(valIndFromMflow.m_flow_x, valIndFromMflow.m_flow_x1,  -valIndFromMflow.m_flow_x1, valIndFromMflow.dp_y1, valIndFromMflow.dp_y2, AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der(valIndFromMflow.phi+valIndFromMflow.m_flow_x1, valIndFromMflow.Kv_SI, valIndFromMflow.m_flow_turbulent, 1), valIndFromMflow.coeff2, AixLib.Fluid.BaseClasses....")
  AixLib_Utilities_Math_Functions_quinticHermite(DYNX(W_,138), DYNX(W_,139), 
  DYNX(DYNhelp,92), DYNX(W_,137), DYNX(W_,136), AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der
  (DYNX(DYNhelp,90), DYNX(W_,124), DYNX(W_,116), 1), DYNX(W_,130), 
  AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der2(
  DYNX(DYNhelp,90), DYNX(W_,124), DYNX(W_,116), 1, 0), 0))));
PopModelContext();

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
SetMatrixLeading(Jacobian__, 1, 1, 1, (IF DYNX(DYNhelp,94) THEN 0.0 ELSE IF 
  DYNX(W_,138) >= DYNX(DYNhelp,92) THEN 0.0 ELSE (PushModelContext(1,
  "AixLib.Utilities.Math.Functions.quinticHermite:derf(valIndFromMflow.m_flow_x, valIndFromMflow.m_flow_x1,  -valIndFromMflow.m_flow_x1, valIndFromMflow.dp_y1, valIndFromMflow.dp_y2, AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der(valIndFromMflow.phi+valIndFromMflow.m_flow_x1, valIndFromMflow.Kv_SI, valIndFromMflow.m_flow_turbulent, 1), valIndFromMflow.coeff2, AixLib.Fluid.BaseCla...")
  AixLib_Utilities_Math_Functions_quinticHermite__derf(DYNX(W_,138), 
  DYNX(W_,139), DYNX(DYNhelp,92), DYNX(W_,137), DYNX(W_,136), AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der
  (DYNX(DYNhelp,90), DYNX(W_,124), DYNX(W_,116), 1), DYNX(W_,130), 
  AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der2(
  DYNX(DYNhelp,90), DYNX(W_,124), DYNX(W_,116), 1, 0), 0, 1.0, 0.0, 0.0, 0.0, 
  0.0, 0.0, 0.0, 0.0, 0)))+DYNX(W_,130)*(IF DYNX(W_,138) > DYNX(DYNhelp,92)
   THEN 1.0 ELSE 0.0)*(IF DYNX(DYNhelp,94) THEN 0.0 ELSE IF DYNX(W_,138) >= 
  DYNX(DYNhelp,92) THEN 1.0 ELSE (PushModelContext(1,"AixLib.Utilities.Math.Functions.quinticHermite:derf(valIndFromMflow.m_flow_x, valIndFromMflow.m_flow_x1,  -valIndFromMflow.m_flow_x1, valIndFromMflow.dp_y1, valIndFromMflow.dp_y2, AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der(valIndFromMflow.phi+valIndFromMflow.m_flow_x1, valIndFromMflow.Kv_SI, valIndFromMflow.m_flow_turbulent, 1), valIndFromMflow.coeff2, AixLib.Fluid.BaseCla...")
  AixLib_Utilities_Math_Functions_quinticHermite__derf(DYNX(W_,138), 
  DYNX(W_,139), DYNX(DYNhelp,92), DYNX(W_,137), DYNX(W_,136), AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der
  (DYNX(DYNhelp,90), DYNX(W_,124), DYNX(W_,116), 1), DYNX(W_,130), 
  AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der2(
  DYNX(DYNhelp,90), DYNX(W_,124), DYNX(W_,116), 1, 0), 0, 0.0, 0.0, 0.0, 0.0, 
  1.0, 0.0, 0.0, 0.0, 0)))-(IF DYNX(DYNhelp,94) THEN 1.0 ELSE IF DYNX(W_,138)
   >= DYNX(DYNhelp,92) THEN 0.0 ELSE (PushModelContext(1,"AixLib.Utilities.Math.Functions.quinticHermite:derf(valIndFromMflow.m_flow_x, valIndFromMflow.m_flow_x1,  -valIndFromMflow.m_flow_x1, valIndFromMflow.dp_y1, valIndFromMflow.dp_y2, AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der(valIndFromMflow.phi+valIndFromMflow.m_flow_x1, valIndFromMflow.Kv_SI, valIndFromMflow.m_flow_turbulent, 1), valIndFromMflow.coeff2, AixLib.Fluid.BaseCla...")
  AixLib_Utilities_Math_Functions_quinticHermite__derf(DYNX(W_,138), 
  DYNX(W_,139), DYNX(DYNhelp,92), DYNX(W_,137), DYNX(W_,136), AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der
  (DYNX(DYNhelp,90), DYNX(W_,124), DYNX(W_,116), 1), DYNX(W_,130), 
  AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der2(
  DYNX(DYNhelp,90), DYNX(W_,124), DYNX(W_,116), 1, 0), 0, 0.0, 0.0, 0.0, 1.0, 
  0.0, 0.0, 0.0, 0.0, 0)))*(PushModelContext(1,"AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der(min( -sou.ports[3].m_flow, valIndFromMflow.phi+valIndFromMflow.m_flow_x1), valIndFromMflow.Kv_SI, valIndFromMflow.m_flow_turbulent, (if noEvent( -sou.ports[3].m_flow < valIndFromMflow.phi+valIndFromMflow.m_flow_x1) then -1.0 else 0.0))")
  AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der(
  DYNX(DYNhelp,91), DYNX(W_,124), DYNX(W_,116), IF DYNX(DYNhelp,89) < 
  DYNX(DYNhelp,90) THEN -1.0 ELSE 0.0)));
PopModelContext();

SolveNonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 2, 
  "Tag: simulation.nonlinear[1]");
DYNX(W_,7) = GetVector(x__, 1);
EndNonLinearSystemOfEquationsNH(residue__, x__, 2);
 /* End of Non-Linear Equation Block */ }



DYNX(W_,143) = DYNX(W_,109);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("y.height", "Height of ramps", 0, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("y.duration", "Duration of ramp (= 0.0 gives a Step) [s]", 1, 1,\
 0.0,1E+100,0.0,0,560)
DeclareParameter("y.offset", "Offset of output signal", 2, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("y.startTime", "Output = offset for time < startTime [s]", 3, 0,\
 0.0,0.0,0.0,0,560)
DeclareVariable("y.y", "Connector of Real output signal", 0.0, 0.0,1.0,0.0,0,512)
DeclareVariable("sou.nPorts", "Number of ports [:#(type=Integer)]", 3, 0.0,0.0,\
0.0,0,517)
DeclareVariable("sou.verifyInputs", "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("sou.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, -100000.0,1E+60,1.0,0,776)
DeclareVariable("sou.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 300000, 0.0,100000000.0,100000.0,0,520)
DeclareVariable("sou.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareVariable("sou.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, -100000.0,1E+60,1.0,0,776)
DeclareAlias2("sou.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sou.ports[1].p", 1, 5, 4, 4)
DeclareAlias2("sou.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "sou.ports[1].h_outflow", 1, 5, 5, 4)
DeclareVariable("sou.ports[3].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, -100000.0,1E+60,1.0,0,840)
DeclareAlias2("sou.ports[3].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sou.ports[1].p", 1, 5, 4, 4)
DeclareAlias2("sou.ports[3].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "sou.ports[1].h_outflow", 1, 5, 5, 4)
DeclareVariable("sou.flowDirection", "Allowed flow direction [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 3, 1.0,3.0,0.0,0,2565)
DeclareAlias2("sou.p_in_internal", "Needed to connect to conditional connector [Pa]",\
 "sou.ports[1].p", 1, 5, 4, 1024)
DeclareVariable("sou.X_in_internal[1]", "Needed to connect to conditional connector [kg/kg]",\
 1.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("sou.use_p_in", "Get the pressure from the input connector [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareParameter("sou.p", "Fixed value of pressure [Pa|bar]", 4, 300000, 0.0,\
100000000.0,100000.0,0,560)
DeclareAlias2("sou.p_in", "Prescribed boundary pressure [Pa]", "sou.ports[1].p", 1,\
 5, 4, 0)
DeclareVariable("sou.use_T_in", "Get the temperature from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("sou.T", "Fixed value of temperature [K|degC]", 5, 293.15, 1.0,\
10000.0,300.0,0,560)
DeclareAlias2("sou.T_in_internal", "Needed to connect to conditional connector [K|degC]",\
 "sou.T", 1, 7, 5, 1024)
DeclareAlias2("sou.h_internal", "[J/kg]", "sou.ports[1].h_outflow", 1, 5, 5, 1024)
DeclareVariable("sou.use_X_in", "Get the composition (all fractions) from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("sou.use_Xi_in", "Get the composition (independent fractions) from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("sou.use_C_in", "Get the trace substances from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("sou.X[1]", "Fixed value of composition [kg/kg]", 6, 1, 0.0,1.0,\
0.1,0,560)
DeclareVariable("sin.nPorts", "Number of ports [:#(type=Integer)]", 3, 0.0,0.0,\
0.0,0,517)
DeclareVariable("sin.verifyInputs", "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("sin.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou.ports[1].m_flow", -1, 5, 3, 132)
DeclareAlias2("sin.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin.p", 1, 7, 7, 4)
DeclareVariable("sin.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareAlias2("sin.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou.ports[2].m_flow", -1, 5, 6, 132)
DeclareAlias2("sin.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin.p", 1, 7, 7, 4)
DeclareAlias2("sin.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "sin.ports[1].h_outflow", 1, 5, 17, 4)
DeclareAlias2("sin.ports[3].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou.ports[3].m_flow", -1, 5, 7, 132)
DeclareAlias2("sin.ports[3].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin.p", 1, 7, 7, 4)
DeclareAlias2("sin.ports[3].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "sin.ports[1].h_outflow", 1, 5, 17, 4)
DeclareVariable("sin.flowDirection", "Allowed flow direction [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 3, 1.0,3.0,0.0,0,2565)
DeclareAlias2("sin.p_in_internal", "Needed to connect to conditional connector [Pa]",\
 "sin.p", 1, 7, 7, 1024)
DeclareVariable("sin.X_in_internal[1]", "Needed to connect to conditional connector [kg/kg]",\
 1.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("sin.use_p_in", "Get the pressure from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("sin.p", "Fixed value of pressure [Pa|Pa]", 7, 300000.0, 0.0,\
100000000.0,100000.0,0,560)
DeclareVariable("sin.use_T_in", "Get the temperature from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("sin.T", "Fixed value of temperature [K|degC]", 8, 293.15, 1.0,\
10000.0,300.0,0,560)
DeclareAlias2("sin.T_in_internal", "Needed to connect to conditional connector [K|degC]",\
 "sin.T", 1, 7, 8, 1024)
DeclareAlias2("sin.h_internal", "[J/kg]", "sin.ports[1].h_outflow", 1, 5, 17, 1024)
DeclareVariable("sin.use_X_in", "Get the composition (all fractions) from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("sin.use_Xi_in", "Get the composition (independent fractions) from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("sin.use_C_in", "Get the trace substances from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("sin.X[1]", "Fixed value of composition [kg/kg]", 9, 1, 0.0,1.0,\
0.1,0,560)
DeclareVariable("valInd.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("valInd.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou.ports[1].m_flow", -1, 5, 3, 132)
DeclareAlias2("valInd.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sou.ports[1].p", 1, 5, 4, 4)
DeclareAlias2("valInd.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "sin.ports[1].h_outflow", 1, 5, 17, 4)
DeclareAlias2("valInd.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou.ports[1].m_flow", 1, 5, 3, 132)
DeclareAlias2("valInd.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin.p", 1, 7, 7, 4)
DeclareAlias2("valInd.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "sou.ports[1].h_outflow", 1, 5, 5, 4)
DeclareVariable("valInd.m_flow_nominal", "Nominal mass flow rate [kg/s]", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("valInd.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.0001, 0.0,1E+100,0.0,0,513)
DeclareVariable("valInd.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("valInd.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "sou.ports[1].m_flow", -1, 5, 3, 0)
DeclareVariable("valInd.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,6000.0,0,512)
DeclareVariable("valInd._m_flow_start", "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valInd._dp_start", "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valInd.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("valInd.dp_nominal", "Pressure drop at nominal mass flow rate [Pa|Pa]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("valInd.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("valInd.linearized", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("valInd.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent [kg/s]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareParameter("valInd.sta_default.p", "Absolute pressure of medium [Pa|bar]",\
 10, 300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareParameter("valInd.sta_default.T", "Temperature of medium [K|degC]", 11, \
293.15, 1.0,10000.0,300.0,0,2608)
DeclareVariable("valInd.eta_default", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 0.001, 0.0,1E+100,0.0,0,2561)
DeclareVariable("valInd.m_flow_nominal_pos", "Absolute value of nominal flow rate [kg/s]",\
 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("valInd.dp_nominal_pos", "Absolute value of nominal pressure difference [Pa|Pa]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("_GlobalScope.Modelica.Media.Interfaces.PartialPureSubstance.X_default[1]",\
 "Default value for mass fractions of medium (for initialization) [kg/kg]", 1, \
0.0,1.0,0.1,0,2561)
DeclareVariable("valInd.CvData", "Selection of flow coefficient [:#(type=AixLib.Fluid.Types.CvTypes)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("valInd.Kv", "Kv (metric) flow coefficient [m3/h/(bar)^(1/2)] []",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("valInd.Cv", "Cv (US) flow coefficient [USG/min/(psi)^(1/2)] []",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("valInd.Av", "Av (metric) flow coefficient [m2]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareParameter("valInd.deltaM", "Fraction of nominal flow rate where linearization starts, if y=1 [1]",\
 12, 0.02, 0.0,0.0,0.0,0,560)
DeclareParameter("valInd.dpValve_nominal", "Nominal pressure drop of fully open valve, used if CvData=AixLib.Fluid.Types.CvTypes.OpPoint [Pa|Pa]",\
 13, 10000, 0.0,1E+100,0.0,0,560)
DeclareParameter("valInd.rhoStd", "Inlet density for which valve coefficients are defined [kg/m3|g/cm3]",\
 14, 995.586, 0.0,1E+100,0.0,0,560)
DeclareVariable("valInd.Kv_SI", "Flow coefficient for fully open valve in SI units, Kv=m_flow/sqrt(dp) [kg/s/(Pa)^(1/2)] []",\
 1E-60, 1E-60,1E+100,0.0,0,2561)
DeclareVariable("valInd.use_inputFilter", "= true, if opening is filtered with a 2nd order CriticalDamping filter [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("valInd.riseTime", "Rise time of the filter (time to reach 99.6 % of an opening step) [s]",\
 15, 120, 0.0,0.0,0.0,0,560)
DeclareParameter("valInd.order", "Order of filter [:#(type=Integer)]", 16, 2, \
1.0,1E+100,0.0,0,564)
DeclareParameter("valInd.init", "Type of initialization (no init/steady state/initial state/initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 17, 4, 1.0,4.0,0.0,0,564)
DeclareParameter("valInd.y_start", "Initial value of output", 18, 1, 0.0,0.0,0.0,\
0,560)
DeclareAlias2("valInd.y", "Actuator position (0: closed, 1: open)", "y.y", 1, 5,\
 0, 0)
DeclareAlias2("valInd.y_actual", "Actual valve position", "y.y", 1, 5, 0, 0)
DeclareVariable("valInd.dpFixed_nominal", "Pressure drop of pipe and other resistances that are in series [Pa|Pa]",\
 0, 0.0,1E+100,0.0,0,513)
DeclareParameter("valInd.l", "Valve leakage, l=Kv(y=0)/Kv(y=1) [1]", 19, 0.05, \
1E-10,1.0,0.0,0,560)
DeclareVariable("valInd.phi", "Ratio actual to nominal mass flow rate of valve, phi=Kv(y)/Kv(y=1) [1]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("valInd.kFixed", "Flow coefficient of fixed resistance that may be in series with valve, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareAlias2("valInd.kVal", "Flow coefficient of valve, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).",\
 "valInd.Kv_SI", 1, 5, 45, 0)
DeclareAlias2("valInd.k", "Flow coefficient of valve and pipe in series, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).",\
 "valInd.Kv_SI", 1, 5, 45, 0)
DeclareParameter("valInd.l2", "Gain for mass flow increase if pressure is above nominal pressure [1]",\
 20, 0.1, 1E-10,1E+100,0.0,0,560)
DeclareParameter("valInd.deltax", "Transition interval for flow rate [1]", 21, \
0.02, 0.0,0.0,0.0,0,560)
DeclareVariable("valInd.coeff1", "Parameter for avoiding unnecessary computations [m.s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valInd.coeff2", "Parameter for avoiding unnecessary computations [m-1.s-1]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valInd.y2dd", "Second derivative at second support point", 0, \
0.0,0.0,0.0,0,2561)
DeclareAlias2("valInd.m_flow_set", "Requested mass flow rate [kg/s]", \
"valInd.phi", 1, 5, 48, 1024)
DeclareVariable("valInd.dp_min", "Minimum pressure difference required for delivering requested mass flow rate [Pa|Pa]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("valInd.dp_x", "[Pa|bar]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("valInd.dp_x1", "[Pa|bar]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("valInd.dp_x2", "[Pa|bar]", "valInd.dp_x1", -1, 5, 55, 1024)
DeclareVariable("valInd.dp_y2", "[Pa|bar]", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valInd.dp_y1", "Support points for interpolation flow functions [Pa|bar]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valInd.m_flow_x", "[kg/s]", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valInd.m_flow_x1", "[kg/s]", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valInd.m_flow_x2", "[kg/s]", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valInd.m_flow_y2", "[kg/s]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("valInd.m_flow_y1", "Support points for interpolation flow functions [kg/s]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("valInd.m_flow_smooth", "Smooth interpolation result between two flow regimes [kg/s]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("valInd.dp_smooth", "Smooth interpolation result between two flow regimes [Pa|bar]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareParameter("dp.height", "Height of ramps [Pa]", 22, 12000, 0.0,0.0,0.0,0,560)
DeclareParameter("dp.duration", "Duration of ramp (= 0.0 gives a Step) [s]", 23,\
 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("dp.offset", "Offset of output signal [Pa]", 24, 303000, \
0.0,0.0,0.0,0,560)
DeclareParameter("dp.startTime", "Output = offset for time < startTime [s]", 25,\
 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("dp.y", "Connector of Real output signal [Pa]", "sou.ports[1].p", 1,\
 5, 4, 0)
DeclareVariable("valIndDpFix.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("valIndDpFix.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou.ports[2].m_flow", -1, 5, 6, 132)
DeclareAlias2("valIndDpFix.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sou.ports[1].p", 1, 5, 4, 4)
DeclareAlias2("valIndDpFix.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "sin.ports[1].h_outflow", 1, 5, 17, 4)
DeclareAlias2("valIndDpFix.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou.ports[2].m_flow", 1, 5, 6, 132)
DeclareAlias2("valIndDpFix.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin.p", 1, 7, 7, 4)
DeclareAlias2("valIndDpFix.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "sou.ports[1].h_outflow", 1, 5, 5, 4)
DeclareVariable("valIndDpFix.m_flow_nominal", "Nominal mass flow rate [kg/s]", 1,\
 0.0,0.0,0.0,0,513)
DeclareVariable("valIndDpFix.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.0001, 0.0,1E+100,0.0,0,513)
DeclareVariable("valIndDpFix.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("valIndDpFix.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "sou.ports[2].m_flow", -1, 5, 6, 0)
DeclareVariable("valIndDpFix.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,6000.0,0,512)
DeclareVariable("valIndDpFix._m_flow_start", "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valIndDpFix._dp_start", "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valIndDpFix.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("valIndDpFix.dp_nominal", "Pressure drop at nominal mass flow rate [Pa|Pa]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("valIndDpFix.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("valIndDpFix.linearized", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("valIndDpFix.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent [kg/s]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareParameter("valIndDpFix.sta_default.p", "Absolute pressure of medium [Pa|bar]",\
 26, 300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareParameter("valIndDpFix.sta_default.T", "Temperature of medium [K|degC]", 27,\
 293.15, 1.0,10000.0,300.0,0,2608)
DeclareVariable("valIndDpFix.eta_default", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 0.001, 0.0,1E+100,0.0,0,2561)
DeclareVariable("valIndDpFix.m_flow_nominal_pos", "Absolute value of nominal flow rate [kg/s]",\
 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("valIndDpFix.dp_nominal_pos", "Absolute value of nominal pressure difference [Pa|Pa]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valIndDpFix.CvData", "Selection of flow coefficient [:#(type=AixLib.Fluid.Types.CvTypes)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("valIndDpFix.Kv", "Kv (metric) flow coefficient [m3/h/(bar)^(1/2)] []",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("valIndDpFix.Cv", "Cv (US) flow coefficient [USG/min/(psi)^(1/2)] []",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("valIndDpFix.Av", "Av (metric) flow coefficient [m2]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareParameter("valIndDpFix.deltaM", "Fraction of nominal flow rate where linearization starts, if y=1 [1]",\
 28, 0.02, 0.0,0.0,0.0,0,560)
DeclareParameter("valIndDpFix.dpValve_nominal", "Nominal pressure drop of fully open valve, used if CvData=AixLib.Fluid.Types.CvTypes.OpPoint [Pa|Pa]",\
 29, 10000, 0.0,1E+100,0.0,0,560)
DeclareParameter("valIndDpFix.rhoStd", "Inlet density for which valve coefficients are defined [kg/m3|g/cm3]",\
 30, 995.586, 0.0,1E+100,0.0,0,560)
DeclareVariable("valIndDpFix.Kv_SI", "Flow coefficient for fully open valve in SI units, Kv=m_flow/sqrt(dp) [kg/s/(Pa)^(1/2)] []",\
 1E-60, 1E-60,1E+100,0.0,0,2561)
DeclareVariable("valIndDpFix.use_inputFilter", "= true, if opening is filtered with a 2nd order CriticalDamping filter [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("valIndDpFix.riseTime", "Rise time of the filter (time to reach 99.6 % of an opening step) [s]",\
 31, 120, 0.0,0.0,0.0,0,560)
DeclareParameter("valIndDpFix.order", "Order of filter [:#(type=Integer)]", 32, 2,\
 1.0,1E+100,0.0,0,564)
DeclareParameter("valIndDpFix.init", "Type of initialization (no init/steady state/initial state/initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 33, 4, 1.0,4.0,0.0,0,564)
DeclareParameter("valIndDpFix.y_start", "Initial value of output", 34, 1, \
0.0,0.0,0.0,0,560)
DeclareAlias2("valIndDpFix.y", "Actuator position (0: closed, 1: open)", "y.y", 1,\
 5, 0, 0)
DeclareAlias2("valIndDpFix.y_actual", "Actual valve position", "y.y", 1, 5, 0, 0)
DeclareVariable("valIndDpFix.dpFixed_nominal", "Pressure drop of pipe and other resistances that are in series [Pa|Pa]",\
 5000, 0.0,1E+100,0.0,0,513)
DeclareParameter("valIndDpFix.l", "Valve leakage, l=Kv(y=0)/Kv(y=1) [1]", 35, \
0.05, 1E-10,1.0,0.0,0,560)
DeclareVariable("valIndDpFix.phi", "Ratio actual to nominal mass flow rate of valve, phi=Kv(y)/Kv(y=1) [1]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("valIndDpFix.kFixed", "Flow coefficient of fixed resistance that may be in series with valve, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareAlias2("valIndDpFix.kVal", "Flow coefficient of valve, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).",\
 "valIndDpFix.Kv_SI", 1, 5, 84, 0)
DeclareVariable("valIndDpFix.k", "Flow coefficient of valve and pipe in series, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).",\
 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareParameter("valIndDpFix.l2", "Gain for mass flow increase if pressure is above nominal pressure [1]",\
 36, 0.1, 1E-10,1E+100,0.0,0,560)
DeclareParameter("valIndDpFix.deltax", "Transition interval for flow rate [1]", 37,\
 0.02, 0.0,0.0,0.0,0,560)
DeclareVariable("valIndDpFix.coeff1", "Parameter for avoiding unnecessary computations [m.s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valIndDpFix.coeff2", "Parameter for avoiding unnecessary computations [m-1.s-1]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valIndDpFix.y2dd", "Second derivative at second support point",\
 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("valIndDpFix.m_flow_set", "Requested mass flow rate [kg/s]", \
"valIndDpFix.phi", 1, 5, 87, 1024)
DeclareVariable("valIndDpFix.dp_min", "Minimum pressure difference required for delivering requested mass flow rate [Pa|Pa]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("valIndDpFix.dp_x", "[Pa|bar]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("valIndDpFix.dp_x1", "[Pa|bar]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("valIndDpFix.dp_x2", "[Pa|bar]", "valIndDpFix.dp_x1", -1, 5, 95, 1024)
DeclareVariable("valIndDpFix.dp_y2", "[Pa|bar]", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valIndDpFix.dp_y1", "Support points for interpolation flow functions [Pa|bar]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valIndDpFix.m_flow_x", "[kg/s]", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valIndDpFix.m_flow_x1", "[kg/s]", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valIndDpFix.m_flow_x2", "[kg/s]", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valIndDpFix.m_flow_y2", "[kg/s]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("valIndDpFix.m_flow_y1", "Support points for interpolation flow functions [kg/s]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("valIndDpFix.m_flow_smooth", "Smooth interpolation result between two flow regimes [kg/s]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("valIndDpFix.dp_smooth", "Smooth interpolation result between two flow regimes [Pa|bar]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valIndFromMflow.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("valIndFromMflow.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou.ports[3].m_flow", -1, 5, 7, 132)
DeclareAlias2("valIndFromMflow.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sou.ports[1].p", 1, 5, 4, 4)
DeclareAlias2("valIndFromMflow.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "sin.ports[1].h_outflow", 1, 5, 17, 4)
DeclareAlias2("valIndFromMflow.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou.ports[3].m_flow", 1, 5, 7, 132)
DeclareAlias2("valIndFromMflow.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin.p", 1, 7, 7, 4)
DeclareAlias2("valIndFromMflow.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "sou.ports[1].h_outflow", 1, 5, 5, 4)
DeclareVariable("valIndFromMflow.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("valIndFromMflow.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.0001, 0.0,1E+100,0.0,0,513)
DeclareVariable("valIndFromMflow.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("valIndFromMflow.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "sou.ports[3].m_flow", -1, 5, 7, 0)
DeclareVariable("valIndFromMflow.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,6000.0,0,512)
DeclareVariable("valIndFromMflow._m_flow_start", "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valIndFromMflow._dp_start", "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valIndFromMflow.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("valIndFromMflow.dp_nominal", "Pressure drop at nominal mass flow rate [Pa|Pa]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("valIndFromMflow.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("valIndFromMflow.linearized", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("valIndFromMflow.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent [kg/s]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareParameter("valIndFromMflow.sta_default.p", "Absolute pressure of medium [Pa|bar]",\
 38, 300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareParameter("valIndFromMflow.sta_default.T", "Temperature of medium [K|degC]",\
 39, 293.15, 1.0,10000.0,300.0,0,2608)
DeclareVariable("valIndFromMflow.eta_default", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 0.001, 0.0,1E+100,0.0,0,2561)
DeclareVariable("valIndFromMflow.m_flow_nominal_pos", "Absolute value of nominal flow rate [kg/s]",\
 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("valIndFromMflow.dp_nominal_pos", "Absolute value of nominal pressure difference [Pa|Pa]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valIndFromMflow.CvData", "Selection of flow coefficient [:#(type=AixLib.Fluid.Types.CvTypes)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("valIndFromMflow.Kv", "Kv (metric) flow coefficient [m3/h/(bar)^(1/2)] []",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("valIndFromMflow.Cv", "Cv (US) flow coefficient [USG/min/(psi)^(1/2)] []",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("valIndFromMflow.Av", "Av (metric) flow coefficient [m2]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareParameter("valIndFromMflow.deltaM", "Fraction of nominal flow rate where linearization starts, if y=1 [1]",\
 40, 0.02, 0.0,0.0,0.0,0,560)
DeclareParameter("valIndFromMflow.dpValve_nominal", "Nominal pressure drop of fully open valve, used if CvData=AixLib.Fluid.Types.CvTypes.OpPoint [Pa|Pa]",\
 41, 10000, 0.0,1E+100,0.0,0,560)
DeclareParameter("valIndFromMflow.rhoStd", "Inlet density for which valve coefficients are defined [kg/m3|g/cm3]",\
 42, 995.586, 0.0,1E+100,0.0,0,560)
DeclareVariable("valIndFromMflow.Kv_SI", "Flow coefficient for fully open valve in SI units, Kv=m_flow/sqrt(dp) [kg/s/(Pa)^(1/2)] []",\
 1E-60, 1E-60,1E+100,0.0,0,2561)
DeclareVariable("valIndFromMflow.use_inputFilter", "= true, if opening is filtered with a 2nd order CriticalDamping filter [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("valIndFromMflow.riseTime", "Rise time of the filter (time to reach 99.6 % of an opening step) [s]",\
 43, 120, 0.0,0.0,0.0,0,560)
DeclareParameter("valIndFromMflow.order", "Order of filter [:#(type=Integer)]", 44,\
 2, 1.0,1E+100,0.0,0,564)
DeclareParameter("valIndFromMflow.init", "Type of initialization (no init/steady state/initial state/initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 45, 4, 1.0,4.0,0.0,0,564)
DeclareParameter("valIndFromMflow.y_start", "Initial value of output", 46, 1, \
0.0,0.0,0.0,0,560)
DeclareAlias2("valIndFromMflow.y", "Actuator position (0: closed, 1: open)", \
"y.y", 1, 5, 0, 0)
DeclareAlias2("valIndFromMflow.y_actual", "Actual valve position", "y.y", 1, 5, 0,\
 0)
DeclareVariable("valIndFromMflow.dpFixed_nominal", "Pressure drop of pipe and other resistances that are in series [Pa|Pa]",\
 0, 0.0,1E+100,0.0,0,513)
DeclareParameter("valIndFromMflow.l", "Valve leakage, l=Kv(y=0)/Kv(y=1) [1]", 47,\
 0.05, 1E-10,1.0,0.0,0,560)
DeclareVariable("valIndFromMflow.phi", "Ratio actual to nominal mass flow rate of valve, phi=Kv(y)/Kv(y=1) [1]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("valIndFromMflow.kFixed", "Flow coefficient of fixed resistance that may be in series with valve, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareAlias2("valIndFromMflow.kVal", "Flow coefficient of valve, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).",\
 "valIndFromMflow.Kv_SI", 1, 5, 124, 0)
DeclareAlias2("valIndFromMflow.k", "Flow coefficient of valve and pipe in series, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).",\
 "valIndFromMflow.Kv_SI", 1, 5, 124, 0)
DeclareParameter("valIndFromMflow.l2", "Gain for mass flow increase if pressure is above nominal pressure [1]",\
 48, 0.1, 1E-10,1E+100,0.0,0,560)
DeclareParameter("valIndFromMflow.deltax", "Transition interval for flow rate [1]",\
 49, 0.02, 0.0,0.0,0.0,0,560)
DeclareVariable("valIndFromMflow.coeff1", "Parameter for avoiding unnecessary computations [m.s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valIndFromMflow.coeff2", "Parameter for avoiding unnecessary computations [m-1.s-1]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valIndFromMflow.y2dd", "Second derivative at second support point",\
 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("valIndFromMflow.m_flow_set", "Requested mass flow rate [kg/s]", \
"valIndFromMflow.phi", 1, 5, 127, 1024)
DeclareVariable("valIndFromMflow.dp_min", "Minimum pressure difference required for delivering requested mass flow rate [Pa|Pa]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("valIndFromMflow.dp_x", "[Pa|bar]", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valIndFromMflow.dp_x1", "[Pa|bar]", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valIndFromMflow.dp_x2", "[Pa|bar]", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valIndFromMflow.dp_y2", "[Pa|bar]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("valIndFromMflow.dp_y1", "Support points for interpolation flow functions [Pa|bar]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("valIndFromMflow.m_flow_x", "[kg/s]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("valIndFromMflow.m_flow_x1", "[kg/s]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("valIndFromMflow.m_flow_x2", "[kg/s]", "valIndFromMflow.m_flow_x1", -1,\
 5, 139, 1024)
DeclareVariable("valIndFromMflow.m_flow_y2", "[kg/s]", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valIndFromMflow.m_flow_y1", "Support points for interpolation flow functions [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valIndFromMflow.m_flow_smooth", "Smooth interpolation result between two flow regimes [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("valIndFromMflow.dp_smooth", "Smooth interpolation result between two flow regimes [Pa|bar]",\
 0.0, 0.0,0.0,0.0,0,2560)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
if (initialCall) DYNX(did_->xInitial_var, 0)=DYNX(W_,7);
else if (DYNHReject) DYNX(W_,7)=did_->xInitial_var2[0]; else did_->xInitial_var2[0]=
  DYNX(W_,7);
}
StartDataBlock
StartEqBlock
DoRemember_(DYNX(W_,7), 0, 0);
DYNSetRememberAcceptedBase(0);
EndEqBlock
EndDataBlock
  BreakSectionStart(1);
   /* Linear system of equations to solve. */
  DYNX(W_,7) = 0;
  SolveScalarLinearParametric(DYNX(W_,119),"valIndFromMflow.dp_nominal_pos",  -
    DYNX(W_,109)," -valIndFromMflow.dp", DYNX(W_,7),"sou.ports[3].m_flow");
   /* End of Equation Block */ 

  DYNX(W_,137) = (PushModelContext(1,"AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(min( -sou.ports[3].m_flow, valIndFromMflow.phi+valIndFromMflow.m_flow_x1), valIndFromMflow.Kv_SI, valIndFromMflow.m_flow_turbulent)")
    AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(RealBmin( -
    DYNX(W_,7), DYNX(W_,127)+DYNX(W_,139)), DYNX(W_,124), DYNX(W_,116)));
  PopModelContext();
  DYNX(W_,138) =  -(DYNX(W_,7)+DYNX(W_,127));
  DYNX(W_,136) = DYNX(W_,132)+DYNX(W_,130)*RealBmax(DYNX(W_,138),  -DYNX(W_,139));
  DYNX(W_,143) = IF DYNX(W_,138) <= DYNX(W_,139) THEN DYNX(W_,137) ELSE IF 
    DYNX(W_,138) >=  -DYNX(W_,139) THEN DYNX(W_,136) ELSE (PushModelContext(1,
    "AixLib.Utilities.Math.Functions.quinticHermite(valIndFromMflow.m_flow_x, valIndFromMflow.m_flow_x1,  -valIndFromMflow.m_flow_x1, valIndFromMflow.dp_y1, valIndFromMflow.dp_y2, AixLib.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der(valIndFromMflow.phi+valIndFromMflow.m_flow_x1, valIndFromMflow.Kv_SI, valIndFromMflow.m_flow_turbulent, 1), valIndFromMflow.coeff2, AixLib.Fluid.BaseClasses....")
    AixLib_Utilities_Math_Functions_quinticHermite(DYNX(W_,138), DYNX(W_,139), 
     -DYNX(W_,139), DYNX(W_,137), DYNX(W_,136), AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der
    (DYNX(W_,127)+DYNX(W_,139), DYNX(W_,124), DYNX(W_,116), 1), DYNX(W_,130), 
    AixLib_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der2(
    DYNX(W_,127)+DYNX(W_,139), DYNX(W_,124), DYNX(W_,116), 1, 0), 0));
  PopModelContext();
  BreakSectionEnd()
